<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://example.kafka-site-md.dev/0110/streams/><link rel=alternate type=application/rss+xml href=https://example.kafka-site-md.dev/0110/streams/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Kafka Streams | </title><meta name=description content="Apache Kafka"><meta property="og:title" content="Kafka Streams"><meta property="og:description" content="Apache Kafka"><meta property="og:type" content="website"><meta property="og:url" content="https://example.kafka-site-md.dev/0110/streams/"><meta itemprop=name content="Kafka Streams"><meta itemprop=description content="Apache Kafka"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kafka Streams"><meta name=twitter:description content="Apache Kafka"><link rel=preload href=/scss/main.min.7ed0eb3fc68a0678ca492e0db9c00f8e8d5b776bbb2fb833732191f6bbf02877.css as=style integrity="sha256-ftDrP8aKBnjKSS4NucAPjo1bd2u7L7gzcyGR9rvwKHc=" crossorigin=anonymous><link href=/scss/main.min.7ed0eb3fc68a0678ca492e0db9c00f8e8d5b776bbb2fb833732191f6bbf02877.css rel=stylesheet integrity="sha256-ftDrP8aKBnjKSS4NucAPjo1bd2u7L7gzcyGR9rvwKHc=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="154" height="250" viewBox="0 0 256 416" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M201.816 230.216c-16.186.0-30.697 7.171-40.634 18.461l-25.463-18.026c2.703-7.442 4.255-15.433 4.255-23.797.0-8.219-1.498-16.076-4.112-23.408l25.406-17.835c9.936 11.233 24.409 18.365 40.548 18.365 29.875.0 54.184-24.305 54.184-54.184.0-29.879-24.309-54.184-54.184-54.184s-54.184 24.305-54.184 54.184c0 5.348.808 10.505 2.258 15.389l-25.423 17.844c-10.62-13.175-25.911-22.374-43.333-25.182v-30.64c24.544-5.155 43.037-26.962 43.037-53.019C124.171 24.305 99.862.0 69.987.0 40.112.0 15.803 24.305 15.803 54.184c0 25.708 18.014 47.246 42.067 52.769v31.038C25.044 143.753.0 172.401.0 206.854c0 34.621 25.292 63.374 58.355 68.94v32.774c-24.299 5.341-42.552 27.011-42.552 52.894.0 29.879 24.309 54.184 54.184 54.184s54.184-24.305 54.184-54.184c0-25.883-18.253-47.553-42.552-52.894v-32.775a69.965 69.965.0 0042.6-24.776l25.633 18.143c-1.423 4.84-2.22 9.946-2.22 15.24.0 29.879 24.309 54.184 54.184 54.184S256 314.279 256 284.4c0-29.879-24.309-54.184-54.184-54.184zm0-126.695c14.487.0 26.27 11.788 26.27 26.271s-11.783 26.27-26.27 26.27-26.27-11.787-26.27-26.27 11.783-26.271 26.27-26.271zm-158.1-49.337c0-14.483 11.784-26.27 26.271-26.27s26.27 11.787 26.27 26.27c0 14.483-11.783 26.27-26.27 26.27s-26.271-11.787-26.271-26.27zm52.541 307.278c0 14.483-11.783 26.27-26.27 26.27s-26.271-11.787-26.271-26.27 11.784-26.27 26.271-26.27 26.27 11.787 26.27 26.27zm-26.272-117.97c-20.205.0-36.642-16.434-36.642-36.638.0-20.205 16.437-36.642 36.642-36.642 20.204.0 36.641 16.437 36.641 36.642.0 20.204-16.437 36.638-36.641 36.638zm131.831 67.179c-14.487.0-26.27-11.788-26.27-26.271s11.783-26.27 26.27-26.27 26.27 11.787 26.27 26.27-11.783 26.271-26.27 26.271z" style="fill:#231f20"/></svg></span><span class=navbar-brand__name></span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/41/><span>Documentation</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=/testimonials/><span>Testimonials</span></a></li><li class=nav-item><a class=nav-link href=/community/downloads/><span>Download Kafka</span></a></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>Releases</a><ul class=dropdown-menu><li><a class=dropdown-item href=/41/>4.1</a></li><li><a class=dropdown-item href=/40/>4.0</a></li><li><a class=dropdown-item href=/39/>3.9</a></li><li><a class=dropdown-item href=/38/>3.8</a></li><li><a class=dropdown-item href=/37/>3.7</a></li><li><a class=dropdown-item href=/36/>3.6</a></li><li><a class=dropdown-item href=/35/>3.5</a></li><li><a class=dropdown-item href=/34/>3.4</a></li><li><a class=dropdown-item href=/33/>3.3</a></li><li><a class=dropdown-item href=/32/>3.2</a></li><li><a class=dropdown-item href=/31/>3.1</a></li><li><a class=dropdown-item href=/30/>3.0</a></li><li><a class=dropdown-item href=/28/>2.8</a></li><li><a class=dropdown-item href=/27/>2.7</a></li><li><a class=dropdown-item href=/26/>2.6</a></li><li><a class=dropdown-item href=/25/>2.5</a></li><li><a class=dropdown-item href=/24/>2.4</a></li><li><a class=dropdown-item href=/23/>2.3</a></li><li><a class=dropdown-item href=/22/>2.2</a></li><li><a class=dropdown-item href=/21/>2.1</a></li><li><a class=dropdown-item href=/20/>2.0</a></li><li><a class=dropdown-item href=/11/>1.1</a></li><li><a class=dropdown-item href=/10/>1.0</a></li><li><a class=dropdown-item href=/0110/>0.11.0</a></li><li><a class=dropdown-item href=/0102/>0.10.2</a></li><li><a class=dropdown-item href=/0101/>0.10.1</a></li><li><a class=dropdown-item href=/0100/>0.10.0</a></li><li><a class=dropdown-item href=/090/>0.9.0</a></li><li><a class=dropdown-item href=/082/>0.8.2</a></li><li><a class=dropdown-item href=/081/>0.8.1</a></li><li><a class=dropdown-item href=/080/>0.8.0</a></li><li><a class=dropdown-item href=/07/>0.7</a></li></ul></div></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.e58a36913f949563db0a14b5eaf8f6a5.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/0110/streams/>Return to the regular view of this page</a>.</p></div><h1 class=title>Kafka Streams</h1><ul><li>1: <a href=#pg-542e63d10060f97632b83501d96b983d>Introduction</a></li><li>2: <a href=#pg-89196d4483c0d610d2618b0433ce7901>Quick Start</a></li><li>3: <a href=#pg-249854baba8b3d63d0ee2ec703e4d33d>Write a streams app</a></li><li>4: <a href=#pg-c9ebb9c8c858566cf46639f8c49a6eee>Core Concepts</a></li><li>5: <a href=#pg-19d4817706ed722e399543915ec2c6e2>Architecture</a></li><li>6: <a href=#pg-01bfd138c96bd0bd13a715b6c13a7a65>Upgrade Guide</a></li><li>7: <a href=#pg-bed110fa6b9817aaa2489fc56ae139e4>Streams Developer Guide</a></li><ul></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-542e63d10060f97632b83501d96b983d>1 - Introduction</h1><h1 id=kafka-streams-api>Kafka Streams API<a class=td-heading-self-link href=#kafka-streams-api aria-label="Heading self-link"></a></h1><h1 id=the-easiest-way-to-write-mission-critical-real-time-applications-and-microservices-with-all-the-benefits-of-kafkas-server-side-cluster-technology>The easiest way to write mission-critical real-time applications and microservices with all the benefits of Kafka&rsquo;s server-side cluster technology.<a class=td-heading-self-link href=#the-easiest-way-to-write-mission-critical-real-time-applications-and-microservices-with-all-the-benefits-of-kafkas-server-side-cluster-technology aria-label="Heading self-link"></a></h1><p><img src=/0110/images/streams-welcome.png></p><p><a href=/0110/streams/tutorial/>Write your first app</a> <a href=/0110/streams/quickstart/>Play with demo app</a></p><ul><li>Write standard Java applications</li><li>Exactly-once processing semantics</li><li>No seperate processing cluster required</li><li>Develop on Mac, Linux, Windows</li><li>Elastic, highly scalable, fault-tolerant</li><li>Deploy to containers, VMs, bare metal, cloud</li><li>Equally viable for small, medium, & large use cases</li><li>Fully integrated with Kafka security</li></ul><p><a href=/0110/documentation/streams/developer-guide><img src=/0110/images/icons/documentation.png> <img src=/0110/images/icons/documentation--white.png> Developer manual </a><a href=/0110/documentation/streams/tutorial><img src=/0110/images/icons/tutorials.png> <img src=/0110/images/icons/tutorials--white.png> Tutorials </a><a href=/0110/documentation/streams/core-concepts><img src=/0110/images/icons/architecture.png> <img src=/0110/images/icons/architecture--white.png> Concepts</a></p><h1 id=hello-kafka-streams>Hello Kafka Streams<a class=td-heading-self-link href=#hello-kafka-streams aria-label="Heading self-link"></a></h1><p>The code example below implements a WordCount application that is elastic, highly scalable, fault-tolerant, stateful, and ready to run in production at large scale</p><p>Java 8+ Java 7 Scala</p><pre><code>                import org.apache.kafka.common.serialization.Serdes;
                import org.apache.kafka.streams.KafkaStreams;
                import org.apache.kafka.streams.StreamsConfig;
                import org.apache.kafka.streams.kstream.KStream;
                import org.apache.kafka.streams.kstream.KStreamBuilder;
                import org.apache.kafka.streams.kstream.KTable;

                import java.util.Arrays;
                import java.util.Properties;

                public class WordCountApplication {

                    public static void main(final String[] args) throws Exception {
                        Properties config = new Properties();
                        config.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;wordcount-application&quot;);
                        config.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;kafka-broker1:9092&quot;);
                        config.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
                        config.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());

                        KStreamBuilder builder = new KStreamBuilder();
                        KStream&lt;String, String&gt; textLines = builder.stream(&quot;TextLinesTopic&quot;);
                        KTable&lt;String, Long&gt; wordCounts = textLines
                            .flatMapValues(textLine -&gt; Arrays.asList(textLine.toLowerCase().split(&quot;\W+&quot;)))
                            .groupBy((key, word) -&gt; word)
                            .count(&quot;Counts&quot;);
                        wordCounts.to(Serdes.String(), Serdes.Long(), &quot;WordsWithCountsTopic&quot;);

                        KafkaStreams streams = new KafkaStreams(builder, config);
                        streams.start();
                    }

                }
            


                import org.apache.kafka.common.serialization.Serdes;
                import org.apache.kafka.streams.KafkaStreams;
                import org.apache.kafka.streams.StreamsConfig;
                import org.apache.kafka.streams.kstream.KStream;
                import org.apache.kafka.streams.kstream.KStreamBuilder;
                import org.apache.kafka.streams.kstream.KTable;
                import org.apache.kafka.streams.kstream.KeyValueMapper;
                import org.apache.kafka.streams.kstream.ValueMapper;

                import java.util.Arrays;
                import java.util.Properties;

                public class WordCountApplication {

                    public static void main(final String[] args) throws Exception {
                        Properties config = new Properties();
                        config.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;wordcount-application&quot;);
                        config.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;kafka-broker1:9092&quot;);
                        config.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
                        config.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());

                        KStreamBuilder builder = new KStreamBuilder();
                        KStream&lt;String, String&gt; textLines = builder.stream(&quot;TextLinesTopic&quot;);
                        KTable&lt;String, Long&gt; wordCounts = textLines
                            .flatMapValues(new ValueMapper&lt;String, Iterable&lt;String&gt;&gt;() {
                                @Override
                                public Iterable&lt;String&gt; apply(String textLine) {
                                    return Arrays.asList(textLine.toLowerCase().split(&quot;\W+&quot;));
                                }
                            })
                            .groupBy(new KeyValueMapper&lt;String, String, String&gt;() {
                                @Override
                                public String apply(String key, String word) {
                                    return word;
                                }
                            })
                            .count(&quot;Counts&quot;);
                        wordCounts.to(Serdes.String(), Serdes.Long(), &quot;WordsWithCountsTopic&quot;);

                        KafkaStreams streams = new KafkaStreams(builder, config);
                        streams.start();
                    }

                }
            


                import java.lang.Long
                import java.util.Properties
                import java.util.concurrent.TimeUnit

                import org.apache.kafka.common.serialization._
                import org.apache.kafka.streams._
                import org.apache.kafka.streams.kstream.{KStream, KStreamBuilder, KTable}

                import scala.collection.JavaConverters.asJavaIterableConverter

                object WordCountApplication {

                    def main(args: Array[String]) {
                        val config: Properties = {
                            val p = new Properties()
                            p.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;wordcount-application&quot;)
                            p.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;kafka-broker1:9092&quot;)
                            p.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass)
                            p.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass)
                            p
                        }

                        val builder: KStreamBuilder = new KStreamBuilder()
                        val textLines: KStream[String, String] = builder.stream(&quot;TextLinesTopic&quot;)
                        val wordCounts: KTable[String, Long] = textLines
                            .flatMapValues(textLine =&gt; textLine.toLowerCase.split(&quot;\W+&quot;).toIterable.asJava)
                            .groupBy((_, word) =&gt; word)
                            .count(&quot;Counts&quot;)
                        wordCounts.to(Serdes.String(), Serdes.Long(), &quot;WordsWithCountsTopic&quot;)

                        val streams: KafkaStreams = new KafkaStreams(builder, config)
                        streams.start()

                        Runtime.getRuntime.addShutdownHook(new Thread(() =&gt; {
                            streams.close(10, TimeUnit.SECONDS)
                        }))
                    }

                }
</code></pre><h1 id=see-how-kafka-streams-is-being-used>See how Kafka Streams is being used<a class=td-heading-self-link href=#see-how-kafka-streams-is-being-used aria-label="Heading self-link"></a></h1><p><img src=/0110/images/icons/rabobank.png></p><p>Rabobank is one of the 3 largest banks in the Netherlands. Its digital nervous system, the Business Event Bus, is powered by Apache Kafka and Kafka Streams. <a href=https://www.confluent.io/blog/real-time-financial-alerts-rabobank-apache-kafkas-streams-api/>Learn More</a></p><p><img src=/0110/images/icons/zalando.png></p><p>As the leading online fashion retailer in Europe, Zalando uses Kafka as an ESB (Enterprise Service Bus), which helps us in transitioning from a monolithic to a micro services architecture. Using Kafka for processing event streams enables our technical team to do near-real time business intelligence. <a href=https://kafka-summit.org/sessions/using-kstreams-ktables-calculate-real-time-domain-rankings/>Learn More</a></p><p>Previous <a href=/0110/streams/quickstart/>Next</a></p><ul><li><a href=/documentation>Documentation</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-89196d4483c0d610d2618b0433ce7901>2 - Quick Start</h1><h1 id=play-with-a-streams-application>Play with a Streams Application<a class=td-heading-self-link href=#play-with-a-streams-application aria-label="Heading self-link"></a></h1><p>This tutorial assumes you are starting fresh and have no existing Kafka or ZooKeeper data. However, if you have already started Kafka and Zookeeper, feel free to skip the first two steps.</p><p>Kafka Streams is a client library for building mission-critical real-time applications and microservices, where the input and/or output data is stored in Kafka clusters. Kafka Streams combines the simplicity of writing and deploying standard Java and Scala applications on the client side with the benefits of Kafka&rsquo;s server-side cluster technology to make these applications highly scalable, elastic, fault-tolerant, distributed, and much more.</p><p>This quickstart example will demonstrate how to run a streaming application coded in this library. Here is the gist of the <code>[WordCountDemo](https://github.com/apache/kafka/blob/0.11.0/streams/examples/src/main/java/org/apache/kafka/streams/examples/wordcount/WordCountDemo.java)</code> example code (converted to use Java 8 lambda expressions for easy reading).</p><pre><code>// Serializers/deserializers (serde) for String and Long types
final Serde&lt;String&gt; stringSerde = Serdes.String();
final Serde&lt;Long&gt; longSerde = Serdes.Long();

// Construct a `KStream` from the input topic &quot;streams-plaintext-input&quot;, where message values
// represent lines of text (for the sake of this example, we ignore whatever may be stored
// in the message keys).
KStream&lt;String, String&gt; textLines = builder.stream(stringSerde, stringSerde, &quot;streams-plaintext-input&quot;);

KTable&lt;String, Long&gt; wordCounts = textLines
    // Split each text line, by whitespace, into words.
    .flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split(&quot;\W+&quot;)))

    // Group the text words as message keys
    .groupBy((key, value) -&gt; value)

    // Count the occurrences of each word (message key).
    .count(&quot;Counts&quot;)

// Store the running counts as a changelog stream to the output topic.
wordCounts.to(stringSerde, longSerde, &quot;streams-wordcount-output&quot;);
</code></pre><p>It implements the WordCount algorithm, which computes a word occurrence histogram from the input text. However, unlike other WordCount examples you might have seen before that operate on bounded data, the WordCount demo application behaves slightly differently because it is designed to operate on an <strong>infinite, unbounded stream</strong> of data. Similar to the bounded variant, it is a stateful algorithm that tracks and updates the counts of words. However, since it must assume potentially unbounded input data, it will periodically output its current state and results while continuing to process more data because it cannot know when it has processed &ldquo;all&rdquo; the input data.</p><p>As the first step, we will start Kafka (unless you already have it started) and then we will prepare input data to a Kafka topic, which will subsequently be processed by a Kafka Streams application.</p><h2 id=step-1-download-the-code>Step 1: Download the code<a class=td-heading-self-link href=#step-1-download-the-code aria-label="Heading self-link"></a></h2><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/0.11.0.2/kafka_2.11-0.11.0.2.tgz" title="Kafka downloads">Download</a> the 0.11.0.2 release and un-tar it. Note that there are multiple downloadable Scala versions and we choose to use the recommended version (2.11) here:</p><pre><code>&gt; tar -xzf kafka_2.11-0.11.0.2.tgz
&gt; cd kafka_2.11-0.11.0.2
</code></pre><h2 id=step-2-start-the-kafka-server>Step 2: Start the Kafka server<a class=td-heading-self-link href=#step-2-start-the-kafka-server aria-label="Heading self-link"></a></h2><p>Kafka uses <a href=https://zookeeper.apache.org/>ZooKeeper</a> so you need to first start a ZooKeeper server if you don&rsquo;t already have one. You can use the convenience script packaged with kafka to get a quick-and-dirty single-node ZooKeeper instance.</p><pre><code>&gt; bin/zookeeper-server-start.sh config/zookeeper.properties
[2013-04-22 15:01:37,495] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
...
</code></pre><p>Now start the Kafka server:</p><pre><code>&gt; bin/kafka-server-start.sh config/server.properties
[2013-04-22 15:01:47,028] INFO Verifying properties (kafka.utils.VerifiableProperties)
[2013-04-22 15:01:47,051] INFO Property socket.send.buffer.bytes is overridden to 1048576 (kafka.utils.VerifiableProperties)
...
</code></pre><h2 id=step-3-prepare-input-topic-and-start-kafka-producer>Step 3: Prepare input topic and start Kafka producer<a class=td-heading-self-link href=#step-3-prepare-input-topic-and-start-kafka-producer aria-label="Heading self-link"></a></h2><p>Next, we create the input topic named <strong>streams-plaintext-input</strong> and the output topic named <strong>streams-wordcount-output</strong> :</p><pre><code>&gt; bin/kafka-topics.sh --create \
    --zookeeper localhost:2181 \
    --replication-factor 1 \
    --partitions 1 \
    --topic streams-plaintext-input
Created topic &quot;streams-plaintext-input&quot;.

&gt; bin/kafka-topics.sh --create \
    --zookeeper localhost:2181 \
    --replication-factor 1 \
    --partitions 1 \
    --topic streams-wordcount-output
Created topic &quot;streams-wordcount-output&quot;.
</code></pre><p>The created topic can be described with the same <strong>kafka-topics</strong> tool:</p><pre><code>&gt; bin/kafka-topics.sh --zookeeper localhost:2181 --describe

Topic:streams-plaintext-input	PartitionCount:1	ReplicationFactor:1	Configs:
    Topic: streams-plaintext-input	Partition: 0	Leader: 0	Replicas: 0	Isr: 0
Topic:streams-wordcount-output	PartitionCount:1	ReplicationFactor:1	Configs:
	Topic: streams-wordcount-output	Partition: 0	Leader: 0	Replicas: 0	Isr: 0
</code></pre><h2 id=step-4-start-the-wordcount-application>Step 4: Start the Wordcount Application<a class=td-heading-self-link href=#step-4-start-the-wordcount-application aria-label="Heading self-link"></a></h2><p>The following command starts the WordCount demo application:</p><pre><code>&gt; bin/kafka-run-class.sh org.apache.kafka.streams.examples.wordcount.WordCountDemo
</code></pre><p>The demo application will read from the input topic <strong>streams-plaintext-input</strong> , perform the computations of the WordCount algorithm on each of the read messages, and continuously write its current results to the output topic <strong>streams-wordcount-output</strong>. Hence there won&rsquo;t be any STDOUT output except log entries as the results are written back into in Kafka.</p><p>Now we can start the console producer in a separate terminal to write some input data to this topic:</p><pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic streams-plaintext-input
</code></pre><p>and inspect the output of the WordCount demo application by reading from its output topic with the console consumer in a separate terminal:</p><pre><code>&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 \
    --topic streams-wordcount-output \
    --from-beginning \
    --formatter kafka.tools.DefaultMessageFormatter \
    --property print.key=true \
    --property print.value=true \
    --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer \
    --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer
</code></pre><h2 id=step-5-process-some-data>Step 5: Process some data<a class=td-heading-self-link href=#step-5-process-some-data aria-label="Heading self-link"></a></h2><p>Now let&rsquo;s write some message with the console producer into the input topic <strong>streams-plaintext-input</strong> by entering a single line of text and then hit <return>. This will send a new message to the input topic, where the message key is null and the message value is the string encoded text line that you just entered (in practice, input data for applications will typically be streaming continuously into Kafka, rather than being manually entered as we do in this quickstart):</p><pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic streams-plaintext-input
all streams lead to kafka
</code></pre><p>This message will be processed by the Wordcount application and the following output data will be written to the <strong>streams-wordcount-output</strong> topic and printed by the console consumer:</p><pre><code>&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092
    --topic streams-wordcount-output \
    --from-beginning \
    --formatter kafka.tools.DefaultMessageFormatter \
    --property print.key=true \
    --property print.value=true \
    --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer \
    --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer

all	    1
streams	1
lead	1
to	    1
kafka	1
</code></pre><p>Here, the first column is the Kafka message key in <code>java.lang.String</code> format and represents a word that is being counted, and the second column is the message value in <code>java.lang.Long</code>format, representing the word&rsquo;s latest count.</p><p>Now let&rsquo;s continue writing one more message with the console producer into the input topic <strong>streams-plaintext-input</strong>. Enter the text line &ldquo;hello kafka streams&rdquo; and hit <return>. Your terminal should look as follows:</p><pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic streams-plaintext-input
all streams lead to kafka
hello kafka streams
</code></pre><p>In your other terminal in which the console consumer is running, you will observe that the WordCount application wrote new output data:</p><pre><code>&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092
    --topic streams-wordcount-output \
    --from-beginning \
    --formatter kafka.tools.DefaultMessageFormatter \
    --property print.key=true \
    --property print.value=true \
    --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer \
    --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer

all	    1
streams	1
lead	1
to	    1
kafka	1
hello	1
kafka	2
streams	2
</code></pre><p>Here the last printed lines <strong>kafka 2</strong> and <strong>streams 2</strong> indicate updates to the keys <strong>kafka</strong> and <strong>streams</strong> whose counts have been incremented from <strong>1</strong> to <strong>2</strong>. Whenever you write further input messages to the input topic, you will observe new messages being added to the <strong>streams-wordcount-output</strong> topic, representing the most recent word counts as computed by the WordCount application. Let&rsquo;s enter one final input text line &ldquo;join kafka summit&rdquo; and hit <return>in the console producer to the input topic <strong>streams-wordcount-input</strong> before we wrap up this quickstart:</p><pre><code>&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic streams-wordcount-input
all streams lead to kafka
hello kafka streams
join kafka summit
</code></pre><p>The <strong>streams-wordcount-output</strong> topic will subsequently show the corresponding updated word counts (see last three lines):</p><pre><code>&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092
    --topic streams-wordcount-output \
    --from-beginning \
    --formatter kafka.tools.DefaultMessageFormatter \
    --property print.key=true \
    --property print.value=true \
    --property key.deserializer=org.apache.kafka.common.serialization.StringDeserializer \
    --property value.deserializer=org.apache.kafka.common.serialization.LongDeserializer

all	    1
streams	1
lead	1
to	    1
kafka	1
hello	1
kafka	2
streams	2
join	1
kafka	3
summit	1
</code></pre><p>As one can see, outputs of the Wordcount application is actually a continuous stream of updates, where each output record (i.e. each line in the original output above) is an updated count of a single word, aka record key such as &ldquo;kafka&rdquo;. For multiple records with the same key, each later record is an update of the previous one.</p><p>The two diagrams below illustrate what is essentially happening behind the scenes. The first column shows the evolution of the current state of the <code>KTable&lt;String, Long></code> that is counting word occurrences for <code>count</code>. The second column shows the change records that result from state updates to the KTable and that are being sent to the output Kafka topic <strong>streams-wordcount-output</strong>.</p><p><img src=/0110/images/streams-table-updates-02.png> <img src=/0110/images/streams-table-updates-01.png></p><p>First the text line &ldquo;all streams lead to kafka&rdquo; is being processed. The <code>KTable</code> is being built up as each new word results in a new table entry (highlighted with a green background), and a corresponding change record is sent to the downstream <code>KStream</code>.</p><p>When the second text line &ldquo;hello kafka streams&rdquo; is processed, we observe, for the first time, that existing entries in the <code>KTable</code> are being updated (here: for the words &ldquo;kafka&rdquo; and for &ldquo;streams&rdquo;). And again, change records are being sent to the output topic.</p><p>And so on (we skip the illustration of how the third line is being processed). This explains why the output topic has the contents we showed above, because it contains the full record of changes.</p><p>Looking beyond the scope of this concrete example, what Kafka Streams is doing here is to leverage the duality between a table and a changelog stream (here: table = the KTable, changelog stream = the downstream KStream): you can publish every change of the table to a stream, and if you consume the entire changelog stream from beginning to end, you can reconstruct the contents of the table.</p><h2 id=step-6-teardown-the-application>Step 6: Teardown the application<a class=td-heading-self-link href=#step-6-teardown-the-application aria-label="Heading self-link"></a></h2><p>You can now stop the console consumer, the console producer, the Wordcount application, the Kafka broker and the Zookeeper server in order via <strong>Ctrl-C</strong>.</p><p><a href=/0110/streams/>Previous</a> <a href=/0110/streams/tutorial/>Next</a></p><ul><li><a href=/documentation>Documentation</a></li><li><a href=/streams>Streams</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-249854baba8b3d63d0ee2ec703e4d33d>3 - Write a streams app</h1><h1 id=write-your-own-streams-applications>Write your own Streams Applications<a class=td-heading-self-link href=#write-your-own-streams-applications aria-label="Heading self-link"></a></h1><p>In this guide we will start from scratch on setting up your own project to write a stream processing application using Kafka&rsquo;s Streams API. It is highly recommended to read the <a href=/0110/streams/quickstart/>quickstart</a> first on how to run a Streams application written in Kafka Streams if you have not done so.</p><h2 id=setting-up-a-maven-project>Setting up a Maven Project<a class=td-heading-self-link href=#setting-up-a-maven-project aria-label="Heading self-link"></a></h2><p>We are going to use a Kafka Streams Maven Archetype for creating a Streams project structure with the following commands:</p><pre><code>        mvn archetype:generate \
            -DarchetypeGroupId=org.apache.kafka \
            -DarchetypeArtifactId=streams-quickstart-java \
            -DarchetypeVersion=0.11.0.2 \
            -DgroupId=streams.examples \
            -DartifactId=streams.examples \
            -Dversion=0.1 \
            -Dpackage=myapps
</code></pre><p>You can use a different value for <code>groupId</code>, <code>artifactId</code> and <code>package</code> parameters if you like. Assuming the above parameter values are used, this command will create a project structure that looks like this:</p><pre><code>        &gt; tree streams.examples
        streams-quickstart
        |-- pom.xml
        |-- src
            |-- main
                |-- java
                |   |-- myapps
                |       |-- LineSplit.java
                |       |-- Pipe.java
                |       |-- WordCount.java
                |-- resources
                    |-- log4j.properties
</code></pre><p>There are already several example programs written with Streams library under <code>src/main/java</code>. Since we are going to start writing such programs from scratch, we can now delete these examples:</p><pre><code>        &gt; cd streams-quickstart
        &gt; rm src/main/java/myapps/*.java
</code></pre><h2 id=writing-a-first-streams-application-pipe>Writing a first Streams application: Pipe<a class=td-heading-self-link href=#writing-a-first-streams-application-pipe aria-label="Heading self-link"></a></h2><p>It&rsquo;s coding time now! Feel free to open your favorite IDE and import this Maven project, or simply open a text editor and create a java file under <code>src/main/java</code>. Let&rsquo;s name it <code>Pipe.java</code>:</p><pre><code>        package myapps;

        public class Pipe {

            public static void main(String[] args) throws Exception {

            }
        }
</code></pre><p>We are going to fill in the <code>main</code> function to write this pipe program. Note that we will not list the import statements as we go since IDEs can usually add them automatically. However if you are using a text editor you need to manually add the imports, and at the end of this section we&rsquo;ll show the complete code snippet with import statement for you.</p><p>The first step to write a Streams application is to create a <code>java.util.Properties</code> map to specify different Streams execution configuration values as defined in <code>StreamsConfig</code>. A couple of important configuration values you need to set are: <code>StreamsConfig.BOOTSTRAP_SERVERS_CONFIG</code>, which specifies a list of host/port pairs to use for establishing the initial connection to the Kafka cluster, and <code>StreamsConfig.APPLICATION_ID_CONFIG</code>, which gives the unique identifier of your Streams application to distinguish itself with other applications talking to the same Kafka cluster:</p><pre><code>        Properties props = new Properties();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-pipe&quot;);
        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);    // assuming that the Kafka broker this application is talking to runs on local machine with port 9092
</code></pre><p>In addition, you can customize other configurations in the same map, for example, default serialization and deserialization libraries for the record key-value pairs:</p><pre><code>        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());
</code></pre><p>For a full list of configurations of Kafka Streams please refer to this <a href=/0110/#streamsconfigs>table</a>.</p><p>Next we will define the computational logic of our Streams application. In Kafka Streams this computational logic is defined as a <code>topology</code> of connected processor nodes. We can use a topology builder to construct such a topology,</p><pre><code>        final KStreamBuilder builder = new KStreamBuilder();
</code></pre><p>And then create a source stream from a Kafka topic named <code>streams-plaintext-input</code> using this topology builder:</p><pre><code>        KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
</code></pre><p>Now we get a <code>KStream</code> that is continuously generating records from its source Kafka topic <code>streams-plaintext-input</code>. The records are organized as <code>String</code> typed key-value pairs. The simplest thing we can do with this stream is to write it into another Kafka topic, say it&rsquo;s named <code>streams-pipe-output</code>:</p><pre><code>        source.to(&quot;streams-pipe-output&quot;);
</code></pre><p>Note that we can also concatenate the above two lines into a single line as:</p><pre><code>        builder.stream(&quot;streams-plaintext-input&quot;).to(&quot;streams-pipe-output&quot;);
</code></pre><p>we can now construct the Streams client with the two components we have just constructed above: the configuration map and the topology builder object (one can also construct a <code>StreamsConfig</code> object from the <code>props</code> map and then pass that object to the constructor, <code>KafkaStreams</code> have overloaded constructor functions to takes either type).</p><pre><code>        final KafkaStreams streams = new KafkaStreams(builder, props);
</code></pre><p>By calling its <code>start()</code> function we can trigger the execution of this client. The execution won&rsquo;t stop until <code>close()</code> is called on this client. We can, for example, add a shutdown hook with a countdown latch to capture a user interrupt and close the client upon terminating this program:</p><pre><code>        final CountDownLatch latch = new CountDownLatch(1);

        // attach shutdown handler to catch control-c
        Runtime.getRuntime().addShutdownHook(new Thread(&quot;streams-shutdown-hook&quot;) {
            @Override
            public void run() {
                streams.close();
                latch.countDown();
            }
        });

        try {
            streams.start();
            latch.await();
        } catch (Throwable e) {
            System.exit(1);
        }
        System.exit(0);
</code></pre><p>The complete code so far looks like this:</p><pre><code>        package myapps;

        import org.apache.kafka.common.serialization.Serdes;
        import org.apache.kafka.streams.KafkaStreams;
        import org.apache.kafka.streams.StreamsConfig;
        import org.apache.kafka.streams.kstream.KStreamBuilder;

        import java.util.Properties;
        import java.util.concurrent.CountDownLatch;

        public class Pipe {

            public static void main(String[] args) throws Exception {
                Properties props = new Properties();
                props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-pipe&quot;);
                props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
                props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
                props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());

                final KStreamBuilder builder = new KStreamBuilder();

                builder.stream(&quot;streams-plaintext-input&quot;).to(&quot;streams-pipe-output&quot;);

                final KafkaStreams streams = new KafkaStreams(builder, props);
                final CountDownLatch latch = new CountDownLatch(1);

                // attach shutdown handler to catch control-c
                Runtime.getRuntime().addShutdownHook(new Thread(&quot;streams-shutdown-hook&quot;) {
                    @Override
                    public void run() {
                        streams.close();
                        latch.countDown();
                    }
                });

                try {
                    streams.start();
                    latch.await();
                } catch (Throwable e) {
                    System.exit(1);
                }
                System.exit(0);
            }
        }
</code></pre><p>If you already have the Kafka broker up and running at <code>localhost:9092</code>, and the topics <code>streams-plaintext-input</code> and <code>streams-pipe-output</code> created on that broker, you can run this code in your IDE or on the command line, using Maven:</p><pre><code>        &gt; mvn clean package
        &gt; mvn exec:java -Dexec.mainClass=myapps.Pipe
</code></pre><p>For detailed instructions on how to run a Streams application and observe its computing results, please read the <a href=/0110/streams/quickstart/>Play with a Streams Application</a> section. We will not talk about this in the rest of this section.</p><h2 id=writing-a-second-streams-application-line-split>Writing a second Streams application: Line Split<a class=td-heading-self-link href=#writing-a-second-streams-application-line-split aria-label="Heading self-link"></a></h2><p>We have learned how to construct a Streams client with its two key components: the <code>StreamsConfig</code> and <code>TopologyBuilder</code>. Now let&rsquo;s move on to add some real processing logic by augmenting the current topology. We can first create another program by first copy the existing <code>Pipe.java</code> class:</p><pre><code>        &gt; cp src/main/java/myapps/Pipe.java src/main/java/myapps/LineSplit.java
</code></pre><p>And change its class name as well as the application id config to distinguish with the original program:</p><pre><code>        public class Pipe {

            public static void main(String[] args) throws Exception {
                Properties props = new Properties();
                props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-linesplit&quot;);
                // ...
            }
        }
</code></pre><p>Since each of the source stream&rsquo;s record is a <code>String</code> typed key-value pair, let&rsquo;s treat the value string as a text line and split it into words with a <code>FlatMapValues</code> operator:</p><pre><code>        KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
        KStream&lt;String, String&gt; words = builder.flatMapValues(new ValueMapper&lt;String, Iterable&lt;String&gt;&gt;() {
                    @Override
                    public Iterable&lt;String&gt; apply(String value) {
                        return Arrays.asList(value.split(&quot;\W+&quot;));
                    }
                });
</code></pre><p>The operator will take the <code>source</code> stream as its input, and generate a new stream named <code>words</code> by processing each record from its source stream in order and breaking its value string into a list of words, and producing each word as a new record to the output <code>words</code> stream. This is a stateless operator that does not need to keep track of any previously received records or processed results. Note if you are using JDK 8 you can use lambda expression and simplify the above code as:</p><pre><code>        KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
        KStream&lt;String, String&gt; words = source.flatMapValues(value -&gt; Arrays.asList(value.split(&quot;\W+&quot;)));
</code></pre><p>And finally we can write the word stream back into another Kafka topic, say <code>streams-linesplit-output</code>. Again, these two steps can be concatenated as the following (assuming lambda expression is used):</p><pre><code>        KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
        source.flatMapValues(value -&gt; Arrays.asList(value.split(&quot;\W+&quot;)))
              .to(&quot;streams-linesplit-output&quot;);
</code></pre><p>The complete code looks like this (assuming lambda expression is used):</p><pre><code>        package myapps;

        import org.apache.kafka.common.serialization.Serdes;
        import org.apache.kafka.streams.KafkaStreams;
        import org.apache.kafka.streams.StreamsConfig;
        import org.apache.kafka.streams.kstream.KStreamBuilder;
        import org.apache.kafka.streams.kstream.ValueMapper;

        import java.util.Arrays;
        import java.util.Properties;
        import java.util.concurrent.CountDownLatch;

        public class LineSplit {

            public static void main(String[] args) throws Exception {
                Properties props = new Properties();
                props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-linesplit&quot;);
                props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
                props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
                props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());

                final KStreamBuilder builder = new KStreamBuilder();

                KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
                source.flatMapValues(value -&gt; Arrays.asList(value.split(&quot;\W+&quot;)))
                      .to(&quot;streams-linesplit-output&quot;);

                final KafkaStreams streams = new KafkaStreams(builder, props);
                final CountDownLatch latch = new CountDownLatch(1);

                // ... same as Pipe.java below
            }
        }
</code></pre><h2 id=writing-a-third-streams-application-wordcount>Writing a third Streams application: Wordcount<a class=td-heading-self-link href=#writing-a-third-streams-application-wordcount aria-label="Heading self-link"></a></h2><p>Let&rsquo;s now take a step further to add some &ldquo;stateful&rdquo; computations to the topology by counting the occurrence of the words split from the source text stream. Following similar steps let&rsquo;s create another program based on the <code>LineSplit.java</code> class:</p><pre><code>        public class WordCount {

            public static void main(String[] args) throws Exception {
                Properties props = new Properties();
                props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-wordcount&quot;);
                // ...
            }
        }
</code></pre><p>In order to count the words we can first modify the <code>flatMapValues</code> operator to treat all of them as lower case (assuming lambda expression is used):</p><pre><code>        source.flatMapValues(new ValueMapper&lt;String, Iterable&lt;String&gt;&gt;() {
                    @Override
                    public Iterable&lt;String&gt; apply(String value) {
                        return Arrays.asList(value.toLowerCase(Locale.getDefault()).split(&quot;\W+&quot;));
                    }
                });
</code></pre><p>In order to do the counting aggregation we have to first specify that we want to key the stream on the value string, i.e. the lower cased word, with a <code>groupBy</code> operator. This operator generate a new grouped stream, which can then be aggregated by a <code>count</code> operator, which generates a running count on each of the grouped keys:</p><pre><code>        KTable&lt;String, Long&gt; counts =
        source.flatMapValues(new ValueMapper&lt;String, Iterable&lt;String&gt;&gt;() {
                    @Override
                    public Iterable&lt;String&gt; apply(String value) {
                        return Arrays.asList(value.toLowerCase(Locale.getDefault()).split(&quot;\W+&quot;));
                    }
                })
              .groupBy(new KeyValueMapper&lt;String, String, String&gt;() {
                   @Override
                   public String apply(String key, String value) {
                       return value;
                   }
                })
              .count(&quot;Counts&quot;);
</code></pre><p>Note that the <code>count</code> operator has a <code>String</code> typed parameter <code>Counts</code>, which stores the running counts that keep being updated as more records are piped and processed from the source Kafka topic. This <code>Counts</code> store can be queried in real-time, with details described in the <a href=/0110/streams/developer-guide/#streams_interactive_queries>Developer Manual</a>.</p><p>We can also write the <code>counts</code> KTable&rsquo;s changelog stream back into another Kafka topic, say <code>streams-wordcount-output</code>. Note that this time the value type is no longer <code>String</code> but <code>Long</code>, so the default serialization classes are not viable for writing it to Kafka anymore. We need to provide overridden serialization methods for <code>Long</code> types, otherwise a runtime exception will be thrown:</p><pre><code>        counts.to(Serdes.String(), Serdes.Long(), &quot;streams-wordcount-output&quot;);
</code></pre><p>Note that in order to read the changelog stream from topic <code>streams-wordcount-output</code>, one needs to set the value deserialization as <code>org.apache.kafka.common.serialization.LongDeserializer</code>. Details of this can be found in the <a href=/0110/streams/quickstart/>Play with a Streams Application</a> section. Assuming lambda expression from JDK 8 can be used, the above code can be simplified as:</p><pre><code>        KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
        source.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase(Locale.getDefault()).split(&quot;\W+&quot;)))
              .groupBy((key, value) -&gt; value)
              .count(&quot;Counts&quot;)
              .to(Serdes.String(), Serdes.Long(), &quot;streams-wordcount-output&quot;);
</code></pre><p>The complete code looks like this (assuming lambda expression is used):</p><pre><code>        package myapps;

        import org.apache.kafka.common.serialization.Serdes;
        import org.apache.kafka.streams.KafkaStreams;
        import org.apache.kafka.streams.StreamsConfig;
        import org.apache.kafka.streams.kstream.KeyValueMapper;
        import org.apache.kafka.streams.kstream.KStreamBuilder;
        import org.apache.kafka.streams.kstream.ValueMapper;

        import java.util.Arrays;
        import java.util.Locale;
        import java.util.Properties;
        import java.util.concurrent.CountDownLatch;

        public class WordCount {

            public static void main(String[] args) throws Exception {
                Properties props = new Properties();
                props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;streams-wordcount&quot;);
                props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;localhost:9092&quot;);
                props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
                props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());

                final KStreamBuilder builder = new KStreamBuilder();

                KStream&lt;String, String&gt; source = builder.stream(&quot;streams-plaintext-input&quot;);
                source.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase(Locale.getDefault()).split(&quot;\W+&quot;)))
                      .groupBy((key, value) -&gt; value)
                      .count(&quot;Counts&quot;)
                      .to(Serdes.String(), Serdes.Long(), &quot;streams-wordcount-output&quot;);

                final KafkaStreams streams = new KafkaStreams(builder, props);
                final CountDownLatch latch = new CountDownLatch(1);

                // ... same as Pipe.java below
            }
        }
</code></pre><p><a href=/0110/streams/quickstart/>Previous</a> <a href=/0110/streams/developer-guide/>Next</a></p><ul><li><a href=/documentation>Documentation</a></li><li><a href=/streams>Streams</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c9ebb9c8c858566cf46639f8c49a6eee>4 - Core Concepts</h1><h1 id=core-concepts>Core Concepts<a class=td-heading-self-link href=#core-concepts aria-label="Heading self-link"></a></h1><p>Kafka Streams is a client library for processing and analyzing data stored in Kafka. It builds upon important stream processing concepts such as properly distinguishing between event time and processing time, windowing support, and simple yet efficient management of application state.</p><p>Kafka Streams has a <strong>low barrier to entry</strong> : You can quickly write and run a small-scale proof-of-concept on a single machine; and you only need to run additional instances of your application on multiple machines to scale up to high-volume production workloads. Kafka Streams transparently handles the load balancing of multiple instances of the same application by leveraging Kafka&rsquo;s parallelism model.</p><p>Some highlights of Kafka Streams:</p><ul><li>Designed as a <strong>simple and lightweight client library</strong> , which can be easily embedded in any Java application and integrated with any existing packaging, deployment and operational tools that users have for their streaming applications.</li><li>Has <strong>no external dependencies on systems other than Apache Kafka itself</strong> as the internal messaging layer; notably, it uses Kafka&rsquo;s partitioning model to horizontally scale processing while maintaining strong ordering guarantees.</li><li>Supports <strong>fault-tolerant local state</strong> , which enables very fast and efficient stateful operations like windowed joins and aggregations.</li><li>Supports <strong>exactly-once</strong> processing semantics to guarantee that each record will be processed once and only once even when there is a failure on either Streams clients or Kafka brokers in the middle of processing.</li><li>Employs <strong>one-record-at-a-time processing</strong> to achieve millisecond processing latency, and supports <strong>event-time based windowing operations</strong> with late arrival of records.</li><li>Offers necessary stream processing primitives, along with a <strong>high-level Streams DSL</strong> and a <strong>low-level Processor API</strong>.</li></ul><p>We first summarize the key concepts of Kafka Streams.</p><h1 id=stream-processing-topology>Stream Processing Topology<a class=td-heading-self-link href=#stream-processing-topology aria-label="Heading self-link"></a></h1><ul><li>A <strong>stream</strong> is the most important abstraction provided by Kafka Streams: it represents an unbounded, continuously updating data set. A stream is an ordered, replayable, and fault-tolerant sequence of immutable data records, where a <strong>data record</strong> is defined as a key-value pair.</li><li>A <strong>stream processing application</strong> is any program that makes use of the Kafka Streams library. It defines its computational logic through one or more <strong>processor topologies</strong> , where a processor topology is a graph of stream processors (nodes) that are connected by streams (edges).</li><li>A <strong>stream processor</strong> is a node in the processor topology; it represents a processing step to transform data in streams by receiving one input record at a time from its upstream processors in the topology, applying its operation to it, and may subsequently produce one or more output records to its downstream processors.</li></ul><p>There are two special processors in the topology:</p><ul><li><strong>Source Processor</strong> : A source processor is a special type of stream processor that does not have any upstream processors. It produces an input stream to its topology from one or multiple Kafka topics by consuming records from these topics and forward them to its down-stream processors.</li><li><strong>Sink Processor</strong> : A sink processor is a special type of stream processor that does not have down-stream processors. It sends any received records from its up-stream processors to a specified Kafka topic.</li></ul><p>Note that in normal processor nodes other remote systems can also be accessed while processing the current record. Therefore the processed results can either be streamed back into Kafka or written to an external system. <img src=/0110/images/streams-architecture-topology.jpg></p><p>Kafka Streams offers two ways to define the stream processing topology: the <a href=/0110/streams/developer-guide/#streams_dsl><strong>Kafka Streams DSL</strong></a> provides the most common data transformation operations such as <code>map</code>, <code>filter</code>, <code>join</code> and <code>aggregations</code> out of the box; the lower-level <a href=/0110/streams/developer-guide/#streams_processor><strong>Processor API</strong></a> allows developers define and connect custom processors as well as to interact with state stores.</p><p>A processor topology is merely a logical abstraction for your stream processing code. At runtime, the logical topology is instantiated and replicated inside the application for parallel processing (see <strong>Stream Partitions and Tasks</strong> for details).</p><h1 id=time>Time<a class=td-heading-self-link href=#time aria-label="Heading self-link"></a></h1><p>A critical aspect in stream processing is the notion of <strong>time</strong> , and how it is modeled and integrated. For example, some operations such as <strong>windowing</strong> are defined based on time boundaries.</p><p>Common notions of time in streams are:</p><ul><li><strong>Event time</strong> - The point in time when an event or data record occurred, i.e. was originally created &ldquo;at the source&rdquo;. <strong>Example:</strong> If the event is a geo-location change reported by a GPS sensor in a car, then the associated event-time would be the time when the GPS sensor captured the location change.</li><li><strong>Processing time</strong> - The point in time when the event or data record happens to be processed by the stream processing application, i.e. when the record is being consumed. The processing time may be milliseconds, hours, or days etc. later than the original event time. <strong>Example:</strong> Imagine an analytics application that reads and processes the geo-location data reported from car sensors to present it to a fleet management dashboard. Here, processing-time in the analytics application might be milliseconds or seconds (e.g. for real-time pipelines based on Apache Kafka and Kafka Streams) or hours (e.g. for batch pipelines based on Apache Hadoop or Apache Spark) after event-time.</li><li><strong>Ingestion time</strong> - The point in time when an event or data record is stored in a topic partition by a Kafka broker. The difference to event time is that this ingestion timestamp is generated when the record is appended to the target topic by the Kafka broker, not when the record is created &ldquo;at the source&rdquo;. The difference to processing time is that processing time is when the stream processing application processes the record. <strong>For example,</strong> if a record is never processed, there is no notion of processing time for it, but it still has an ingestion time.</li></ul><p>The choice between event-time and ingestion-time is actually done through the configuration of Kafka (not Kafka Streams): From Kafka 0.10.x onwards, timestamps are automatically embedded into Kafka messages. Depending on Kafka&rsquo;s configuration these timestamps represent event-time or ingestion-time. The respective Kafka configuration setting can be specified on the broker level or per topic. The default timestamp extractor in Kafka Streams will retrieve these embedded timestamps as-is. Hence, the effective time semantics of your application depend on the effective Kafka configuration for these embedded timestamps.</p><p>Kafka Streams assigns a <strong>timestamp</strong> to every data record via the <code>TimestampExtractor</code> interface. Concrete implementations of this interface may retrieve or compute timestamps based on the actual contents of data records such as an embedded timestamp field to provide event-time semantics, or use any other approach such as returning the current wall-clock time at the time of processing, thereby yielding processing-time semantics to stream processing applications. Developers can thus enforce different notions of time depending on their business needs. For example, per-record timestamps describe the progress of a stream with regards to time (although records may be out-of-order within the stream) and are leveraged by time-dependent operations such as joins.</p><p>Finally, whenever a Kafka Streams application writes records to Kafka, then it will also assign timestamps to these new records. The way the timestamps are assigned depends on the context:</p><ul><li>When new output records are generated via processing some input record, for example, <code>context.forward()</code> triggered in the <code>process()</code> function call, output record timestamps are inherited from input record timestamps directly.</li><li>When new output records are generated via periodic functions such as <code>punctuate()</code>, the output record timestamp is defined as the current internal time (obtained through <code>context.timestamp()</code>) of the stream task.</li><li>For aggregations, the timestamp of a resulting aggregate update record will be that of the latest arrived input record that triggered the update.</li></ul><h1 id=states>States<a class=td-heading-self-link href=#states aria-label="Heading self-link"></a></h1><p>Some stream processing applications don&rsquo;t require state, which means the processing of a message is independent from the processing of all other messages. However, being able to maintain state opens up many possibilities for sophisticated stream processing applications: you can join input streams, or group and aggregate data records. Many such stateful operators are provided by the <a href=/0110/streams/developer-guide/#streams_dsl><strong>Kafka Streams DSL</strong></a>.</p><p>Kafka Streams provides so-called <strong>state stores</strong> , which can be used by stream processing applications to store and query data. This is an important capability when implementing stateful operations. Every task in Kafka Streams embeds one or more state stores that can be accessed via APIs to store and query data required for processing. These state stores can either be a persistent key-value store, an in-memory hashmap, or another convenient data structure. Kafka Streams offers fault-tolerance and automatic recovery for local state stores.</p><p>Kafka Streams allows direct read-only queries of the state stores by methods, threads, processes or applications external to the stream processing application that created the state stores. This is provided through a feature called <strong>Interactive Queries</strong>. All stores are named and Interactive Queries exposes only the read operations of the underlying implementation.</p><h1 id=processing-guarantees>Processing Guarantees<a class=td-heading-self-link href=#processing-guarantees aria-label="Heading self-link"></a></h1><p>In stream processing, one of the most frequently asked question is &ldquo;does my stream processing system guarantee that each record is processed once and only once, even if some failures are encountered in the middle of processing?&rdquo; Failing to guarantee exactly-once stream processing is a deal-breaker for many applications that cannot tolerate any data-loss or data duplicates, and in that case a batch-oriented framework is usually used in addition to the stream processing pipeline, known as the <a href=https://en.wikipedia.org/wiki/Lambda_architecture>Lambda Architecture</a>. Prior to 0.11.0.0, Kafka only provides at-least-once delivery guarantees and hence any stream processing systems that leverage it as the backend storage could not guarantee end-to-end exactly-once semantics. In fact, even for those stream processing systems that claim to support exactly-once processing, as long as they are reading from / writing to Kafka as the source / sink, their applications cannot actually guarantee that no duplicates will be generated throughout the pipeline. Since the 0.11.0.0 release, Kafka has added support to allow its producers to send messages to different topic partitions in a <a href=/#semantics>transactional and idempotent manner</a>, and Kafka Streams has hence added the end-to-end exactly-once processing semantics by leveraging these features. More specifically, it guarantees that for any record read from the source Kafka topics, its processing results will be reflected exactly once in the output Kafka topic as well as in the state stores for stateful operations. Note the key difference between Kafka Streams end-to-end exactly-once guarantee with other stream processing frameworks&rsquo; claimed guarantees is that Kafka Streams tightly integrates with the underlying Kafka storage system and ensure that commits on the input topic offsets, updates on the state stores, and writes to the output topics will be completed atomically instead of treating Kafka as an external system that may have side-effects. To read more details on how this is done inside Kafka Streams, readers are recommended to read <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-129%3A+Streams+Exactly-Once+Semantics>KIP-129</a>. In order to achieve exactly-once semantics when running Kafka Streams applications, users can simply set the <code>processing.guarantee</code> config value to <strong>exactly_once</strong> (default value is <strong>at_least_once</strong>). More details can be found in the <a href=/0110/documentation#streamsconfigs><strong>Kafka Streams Configs</strong></a> section.</p><p><a href=/0110/streams/developer-guide/>Previous</a> <a href=/0110/streams/architecture/>Next</a></p><ul><li><a href=/documentation>Documentation</a></li><li><a href=/streams>Kafka Streams API</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-19d4817706ed722e399543915ec2c6e2>5 - Architecture</h1><h1 id=architecture>Architecture<a class=td-heading-self-link href=#architecture aria-label="Heading self-link"></a></h1><p>Kafka Streams simplifies application development by building on the Kafka producer and consumer libraries and leveraging the native capabilities of Kafka to offer data parallelism, distributed coordination, fault tolerance, and operational simplicity. In this section, we describe how Kafka Streams works underneath the covers.</p><p>The picture below shows the anatomy of an application that uses the Kafka Streams library. Let&rsquo;s walk through some details.</p><p><img src=/0110/images/streams-architecture-overview.jpg></p><h1 id=stream-partitions-and-tasks>Stream Partitions and Tasks<a class=td-heading-self-link href=#stream-partitions-and-tasks aria-label="Heading self-link"></a></h1><p>The messaging layer of Kafka partitions data for storing and transporting it. Kafka Streams partitions data for processing it. In both cases, this partitioning is what enables data locality, elasticity, scalability, high performance, and fault tolerance. Kafka Streams uses the concepts of <strong>partitions</strong> and <strong>tasks</strong> as logical units of its parallelism model based on Kafka topic partitions. There are close links between Kafka Streams and Kafka in the context of parallelism:</p><ul><li>Each <strong>stream partition</strong> is a totally ordered sequence of data records and maps to a Kafka <strong>topic partition</strong>.</li><li>A <strong>data record</strong> in the stream maps to a Kafka <strong>message</strong> from that topic.</li><li>The <strong>keys</strong> of data records determine the partitioning of data in both Kafka and Kafka Streams, i.e., how data is routed to specific partitions within topics.</li></ul><p>An application&rsquo;s processor topology is scaled by breaking it into multiple tasks. More specifically, Kafka Streams creates a fixed number of tasks based on the input stream partitions for the application, with each task assigned a list of partitions from the input streams (i.e., Kafka topics). The assignment of partitions to tasks never changes so that each task is a fixed unit of parallelism of the application. Tasks can then instantiate their own processor topology based on the assigned partitions; they also maintain a buffer for each of its assigned partitions and process messages one-at-a-time from these record buffers. As a result stream tasks can be processed independently and in parallel without manual intervention.</p><p>Slightly simplified, the maximum parallelism at which your application may run is bounded by the maximum number of stream tasks, which itself is determined by maximum number of partitions of the input topic(s) the application is reading from. For example, if your input topic has 5 partitions, then you can run up to 5 applications instances. These instances will collaboratively process the topic’s data. If you run a larger number of app instances than partitions of the input topic, the “excess” app instances will launch but remain idle; however, if one of the busy instances goes down, one of the idle instances will resume the former’s work.</p><p>It is important to understand that Kafka Streams is not a resource manager, but a library that &ldquo;runs&rdquo; anywhere its stream processing application runs. Multiple instances of the application are executed either on the same machine, or spread across multiple machines and tasks can be distributed automatically by the library to those running application instances. The assignment of partitions to tasks never changes; if an application instance fails, all its assigned tasks will be automatically restarted on other instances and continue to consume from the same stream partitions.</p><p>The following diagram shows two tasks each assigned with one partition of the input streams.</p><p><img src=/0110/images/streams-architecture-tasks.jpg></p><h1 id=threading-model>Threading Model<a class=td-heading-self-link href=#threading-model aria-label="Heading self-link"></a></h1><p>Kafka Streams allows the user to configure the number of <strong>threads</strong> that the library can use to parallelize processing within an application instance. Each thread can execute one or more tasks with their processor topologies independently. For example, the following diagram shows one stream thread running two stream tasks.</p><p><img src=/0110/images/streams-architecture-threads.jpg></p><p>Starting more stream threads or more instances of the application merely amounts to replicating the topology and having it process a different subset of Kafka partitions, effectively parallelizing processing. It is worth noting that there is no shared state amongst the threads, so no inter-thread coordination is necessary. This makes it very simple to run topologies in parallel across the application instances and threads. The assignment of Kafka topic partitions amongst the various stream threads is transparently handled by Kafka Streams leveraging <a href=https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Client-side+Assignment+Proposal>Kafka&rsquo;s coordination</a> functionality.</p><p>As we described above, scaling your stream processing application with Kafka Streams is easy: you merely need to start additional instances of your application, and Kafka Streams takes care of distributing partitions amongst tasks that run in the application instances. You can start as many threads of the application as there are input Kafka topic partitions so that, across all running instances of an application, every thread (or rather, the tasks it runs) has at least one input partition to process.</p><h1 id=local-state-stores>Local State Stores<a class=td-heading-self-link href=#local-state-stores aria-label="Heading self-link"></a></h1><p>Kafka Streams provides so-called <strong>state stores</strong> , which can be used by stream processing applications to store and query data, which is an important capability when implementing stateful operations. The <a href=/0110/streams/developer-guide/#streams_dsl>Kafka Streams DSL</a>, for example, automatically creates and manages such state stores when you are calling stateful operators such as <code>join()</code> or <code>aggregate()</code>, or when you are windowing a stream.</p><p>Every stream task in a Kafka Streams application may embed one or more local state stores that can be accessed via APIs to store and query data required for processing. Kafka Streams offers fault-tolerance and automatic recovery for such local state stores.</p><p>The following diagram shows two stream tasks with their dedicated local state stores.</p><p><img src=/0110/images/streams-architecture-states.jpg></p><h1 id=fault-tolerance>Fault Tolerance<a class=td-heading-self-link href=#fault-tolerance aria-label="Heading self-link"></a></h1><p>Kafka Streams builds on fault-tolerance capabilities integrated natively within Kafka. Kafka partitions are highly available and replicated; so when stream data is persisted to Kafka it is available even if the application fails and needs to re-process it. Tasks in Kafka Streams leverage the fault-tolerance capability offered by the <a href=https://www.confluent.io/blog/tutorial-getting-started-with-the-new-apache-kafka-0.9-consumer-client/>Kafka consumer client</a> to handle failures. If a task runs on a machine that fails, Kafka Streams automatically restarts the task in one of the remaining running instances of the application.</p><p>In addition, Kafka Streams makes sure that the local state stores are robust to failures, too. For each state store, it maintains a replicated changelog Kafka topic in which it tracks any state updates. These changelog topics are partitioned as well so that each local state store instance, and hence the task accessing the store, has its own dedicated changelog topic partition. <a href=/0110/#compaction>Log compaction</a> is enabled on the changelog topics so that old data can be purged safely to prevent the topics from growing indefinitely. If tasks run on a machine that fails and are restarted on another machine, Kafka Streams guarantees to restore their associated state stores to the content before the failure by replaying the corresponding changelog topics prior to resuming the processing on the newly started tasks. As a result, failure handling is completely transparent to the end user.</p><p>Note that the cost of task (re)initialization typically depends primarily on the time for restoring the state by replaying the state stores&rsquo; associated changelog topics. To minimize this restoration time, users can configure their applications to have <strong>standby replicas</strong> of local states (i.e. fully replicated copies of the state). When a task migration happens, Kafka Streams then attempts to assign a task to an application instance where such a standby replica already exists in order to minimize the task (re)initialization cost. See <code>num.standby.replicas</code> in the <a href=/0110/#streamsconfigs><strong>Kafka Streams Configs</strong></a> section.</p><p><a href=/0110/streams/core-concepts/>Previous</a> <a href=/0110/streams/upgrade-guide/>Next</a></p><ul><li><a href=/documentation>Documentation</a></li><li><a href=/streams>Kafka Streams API</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-01bfd138c96bd0bd13a715b6c13a7a65>6 - Upgrade Guide</h1><h1 id=upgrade-guide--api-changes>Upgrade Guide & API Changes<a class=td-heading-self-link href=#upgrade-guide--api-changes aria-label="Heading self-link"></a></h1><p>If you want to upgrade from 0.10.2.x to 0.11.0 you don&rsquo;t need to do any code changes as the public API is fully backward compatible. However, some configuration parameters were deprecated and thus it is recommend to update your code eventually to allow for future upgrades. See below a complete list of 0.11.0 API and semantical changes that allow you to advance your application and/or simplify your code base, including the usage of new features.</p><p>If you want to upgrade from 0.10.1.x to 0.11.0, also see the <a href=/0110/upgrade/#upgrade_1020_streams><strong>Upgrade Section for 0.10.2</strong></a>. It highlights incompatible changes you need to consider to upgrade your code and application. See below a complete list of 0.10.2 and 0.11.0 API and semantical changes that allow you to advance your application and/or simplify your code base, including the usage of new features.</p><p>Upgrading from 0.10.0.x to 0.11.0.x directly is also possible. Note, that a brokers must be on version 0.10.1 or higher to run a Kafka Streams application version 0.10.1 or higher. See Streams API changes in 0.10.1, Streams API changes in 0.10.2, and Streams API changes in 0.11.0 for a complete list of API changes. Upgrading to 0.11.0.3 requires two rolling bounces with config <code>upgrade.from="0.10.0"</code> set for first upgrade phase (cf. <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-268%3A+Simplify+Kafka+Streams+Rebalance+Metadata+Upgrade>KIP-268</a>). As an alternative, an offline upgrade is also possible.</p><ul><li>prepare your application instances for a rolling bounce and make sure that config <code>upgrade.from</code> is set to <code>"0.10.0"</code> for new version 0.11.0.3</li><li>bounce each instance of your application once</li><li>prepare your newly deployed 0.11.0.3 application instances for a second round of rolling bounces; make sure to remove the value for config <code>upgrade.mode</code></li><li>bounce each instance of your application once more to complete the upgrade</li></ul><p>Upgrading from 0.10.0.x to 0.11.0.0, 0.11.0.1, or 0.11.0.2 requires an offline upgrade (rolling bounce upgrade is not supported)</p><ul><li>stop all old (0.10.0.x) application instances</li><li>update your code and swap old code and jar file with new code and new jar file</li><li>restart all new (0.11.0.0, 0.11.0.1, or 0.11.0.2) application instances</li></ul><h1 id=streams-api-changes-in-01100>Streams API changes in 0.11.0.0<a class=td-heading-self-link href=#streams-api-changes-in-01100 aria-label="Heading self-link"></a></h1><p>Updates in <code>StreamsConfig</code>:</p><ul><li>new configuration parameter <code>processing.guarantee</code> is added</li><li>configuration parameter <code>key.serde</code> was deprecated and replaced by <code>default.key.serde</code></li><li>configuration parameter <code>value.serde</code> was deprecated and replaced by <code>default.value.serde</code></li><li>configuration parameter <code>timestamp.extractor</code> was deprecated and replaced by <code>default.timestamp.extractor</code></li><li>method <code>#keySerde()</code> was deprecated and replaced by <code>#defaultKeySerde()</code></li><li>method <code>#valueSerde()</code> was deprecated and replaced by <code>#defaultValueSerde()</code></li><li>new method <code>#defaultTimestampExtractor()</code> was added</li></ul><p>New methods in <code>TopologyBuilder</code>:</p><ul><li>added overloads for <code>#addSource()</code> that allow to define a <code>TimestampExtractor</code> per source node</li><li>added overloads for <code>#addGlobalStore()</code> that allow to define a <code>TimestampExtractor</code> per source node associated with the global store</li></ul><p>New methods in <code>KStreamBuilder</code>:</p><ul><li>added overloads for <code>#stream()</code> that allow to define a <code>TimestampExtractor</code> per input stream</li><li>added overloads for <code>#table()</code> that allow to define a <code>TimestampExtractor</code> per input table</li><li>added overloads for <code>#globalKTable()</code> that allow to define a <code>TimestampExtractor</code> per global table</li></ul><p>Deprecated methods in <code>KTable</code>:</p><ul><li><code>void foreach(final ForeachAction&lt;? super K, ? super V> action)</code></li><li><code>void print()</code></li><li><code>void print(final String streamName)</code></li><li><code>void print(final Serde&lt;K> keySerde, final Serde&lt;V> valSerde)</code></li><li><code>void print(final Serde&lt;K> keySerde, final Serde&lt;V> valSerde, final String streamName)</code></li><li><code>void writeAsText(final String filePath)</code></li><li><code>void writeAsText(final String filePath, final String streamName)</code></li><li><code>void writeAsText(final String filePath, final Serde&lt;K> keySerde, final Serde&lt;V> valSerde)</code></li><li><code>void writeAsText(final String filePath, final String streamName, final Serde&lt;K> keySerde, final Serde&lt;V> valSerde)</code></li></ul><p>The above methods have been deprecated in favor of using the Interactive Queries API. If you want to query the current content of the state store backing the KTable, use the following approach:</p><ul><li>Make a call to <code>KafkaStreams.store(final String storeName, final QueryableStoreType&lt;T> queryableStoreType)</code></li><li>Then make a call to <code>ReadOnlyKeyValueStore.all()</code> to iterate over the keys of a <code>KTable</code>.</li></ul><p>If you want to view the changelog stream of the <code>KTable</code> then you could call <code>KTable.toStream().print()</code>.</p><p>Metrics using exactly-once semantics:</p><p>If exactly-once processing is enabled via the <code>processing.guarantees</code> parameter, internally Streams switches from a producer per thread to a producer per task runtime model. In order to distinguish the different producers, the producer&rsquo;s <code>client.id</code> additionally encodes the task-ID for this case. Because the producer&rsquo;s <code>client.id</code> is used to report JMX metrics, it might be required to update tools that receive those metrics.</p><p>Producer&rsquo;s <code>client.id</code> naming schema:</p><ul><li>at-least-once (default): <code>[client.Id]-StreamThread-[sequence-number]</code></li><li>exactly-once: <code>[client.Id]-StreamThread-[sequence-number]-[taskId]</code></li></ul><p><code>[client.Id]</code> is either set via Streams configuration parameter <code>client.id</code> or defaults to <code>[application.id]-[processId]</code> (<code>[processId]</code> is a random UUID).</p><h1 id=notable-changes-in-01021>Notable changes in 0.10.2.1<a class=td-heading-self-link href=#notable-changes-in-01021 aria-label="Heading self-link"></a></h1><p>Parameter updates in <code>StreamsConfig</code>:</p><ul><li>The default config values of embedded producer&rsquo;s <code>retries</code> and consumer&rsquo;s <code>max.poll.interval.ms</code> have been changed to improve the resiliency of a Kafka Streams application</li></ul><h1 id=streams-api-changes-in-01020>Streams API changes in 0.10.2.0<a class=td-heading-self-link href=#streams-api-changes-in-01020 aria-label="Heading self-link"></a></h1><p>New methods in <code>KafkaStreams</code>:</p><ul><li>set a listener to react on application state change via <code>#setStateListener(StateListener listener)</code></li><li>retrieve the current application state via <code>#state()</code></li><li>retrieve the global metrics registry via <code>#metrics()</code></li><li>apply a timeout when closing an application via <code>#close(long timeout, TimeUnit timeUnit)</code></li><li>specify a custom indent when retrieving Kafka Streams information via <code>#toString(String indent)</code></li></ul><p>Parameter updates in <code>StreamsConfig</code>:</p><ul><li>parameter <code>zookeeper.connect</code> was deprecated; a Kafka Streams application does no longer interact with Zookeeper for topic management but uses the new broker admin protocol (cf. <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-4+-+Command+line+and+centralized+administrative+operations#KIP-4-Commandlineandcentralizedadministrativeoperations-TopicAdminSchema.1>KIP-4, Section &ldquo;Topic Admin Schema&rdquo;</a>)</li><li>added many new parameters for metrics, security, and client configurations</li></ul><p>Changes in <code>StreamsMetrics</code> interface:</p><ul><li>removed methods: <code>#addLatencySensor()</code></li><li>added methods: <code>#addLatencyAndThroughputSensor()</code>, <code>#addThroughputSensor()</code>, <code>#recordThroughput()</code>, <code>#addSensor()</code>, <code>#removeSensor()</code></li></ul><p>New methods in <code>TopologyBuilder</code>:</p><ul><li>added overloads for <code>#addSource()</code> that allow to define a <code>auto.offset.reset</code> policy per source node</li><li>added methods <code>#addGlobalStore()</code> to add global <code>StateStore</code>s</li></ul><p>New methods in <code>KStreamBuilder</code>:</p><ul><li>added overloads for <code>#stream()</code> and <code>#table()</code> that allow to define a <code>auto.offset.reset</code> policy per input stream/table</li><li>added method <code>#globalKTable()</code> to create a <code>GlobalKTable</code></li></ul><p>New joins for <code>KStream</code>:</p><ul><li>added overloads for <code>#join()</code> to join with <code>KTable</code></li><li>added overloads for <code>#join()</code> and <code>leftJoin()</code> to join with <code>GlobalKTable</code></li><li>note, join semantics in 0.10.2 were improved and thus you might see different result compared to 0.10.0.x and 0.10.1.x (cf. <a href=https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams+Join+Semantics>Kafka Streams Join Semantics</a> in the Apache Kafka wiki)</li></ul><p>Aligned <code>null</code>-key handling for <code>KTable</code> joins:</p><ul><li>like all other KTable operations, <code>KTable-KTable</code> joins do not throw an exception on <code>null</code> key records anymore, but drop those records silently</li></ul><p>New window type <em>Session Windows</em> :</p><ul><li>added class <code>SessionWindows</code> to specify session windows</li><li>added overloads for <code>KGroupedStream</code> methods <code>#count()</code>, <code>#reduce()</code>, and <code>#aggregate()</code> to allow session window aggregations</li></ul><p>Changes to <code>TimestampExtractor</code>:</p><ul><li>method <code>#extract()</code> has a second parameter now</li><li>new default timestamp extractor class <code>FailOnInvalidTimestamp</code> (it gives the same behavior as old (and removed) default extractor <code>ConsumerRecordTimestampExtractor</code>)</li><li>new alternative timestamp extractor classes <code>LogAndSkipOnInvalidTimestamp</code> and <code>UsePreviousTimeOnInvalidTimestamps</code></li></ul><p>Relaxed type constraints of many DSL interfaces, classes, and methods (cf. <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-100+-+Relax+Type+constraints+in+Kafka+Streams+API>KIP-100</a>).</p><h1 id=streams-api-changes-in-01010>Streams API changes in 0.10.1.0<a class=td-heading-self-link href=#streams-api-changes-in-01010 aria-label="Heading self-link"></a></h1><p>Stream grouping and aggregation split into two methods:</p><ul><li>old: KStream #aggregateByKey(), #reduceByKey(), and #countByKey()</li><li>new: KStream#groupByKey() plus KGroupedStream #aggregate(), #reduce(), and #count()</li><li>Example: stream.countByKey() changes to stream.groupByKey().count()</li></ul><p>Auto Repartitioning:</p><ul><li>a call to through() after a key-changing operator and before an aggregation/join is no longer required</li><li>Example: stream.selectKey(&mldr;).through(&mldr;).countByKey() changes to stream.selectKey().groupByKey().count()</li></ul><p>TopologyBuilder:</p><ul><li>methods #sourceTopics(String applicationId) and #topicGroups(String applicationId) got simplified to #sourceTopics() and #topicGroups()</li></ul><p>DSL: new parameter to specify state store names:</p><ul><li>The new Interactive Queries feature requires to specify a store name for all source KTables and window aggregation result KTables (previous parameter &ldquo;operator/window name&rdquo; is now the storeName)</li><li>KStreamBuilder#table(String topic) changes to #topic(String topic, String storeName)</li><li>KTable#through(String topic) changes to #through(String topic, String storeName)</li><li>KGroupedStream #aggregate(), #reduce(), and #count() require additional parameter &ldquo;String storeName&rdquo;</li><li>Example: stream.countByKey(TimeWindows.of(&ldquo;windowName&rdquo;, 1000)) changes to stream.groupByKey().count(TimeWindows.of(1000), &ldquo;countStoreName&rdquo;)</li></ul><p>Windowing:</p><ul><li>Windows are not named anymore: TimeWindows.of(&ldquo;name&rdquo;, 1000) changes to TimeWindows.of(1000) (cf. DSL: new parameter to specify state store names)</li><li>JoinWindows has no default size anymore: JoinWindows.of(&ldquo;name&rdquo;).within(1000) changes to JoinWindows.of(1000)</li></ul><p><a href=/0110/streams/architecture/>Previous</a> Next</p><ul><li><a href=/documentation>Documentation</a></li><li><a href=/streams>Kafka Streams API</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bed110fa6b9817aaa2489fc56ae139e4>7 - Streams Developer Guide</h1></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=Contact aria-label=Contact><a target=_blank rel=noopener href=/community/contact/ aria-label=Contact><i class="fa fa-envelope"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Twitter aria-label=Twitter><a target=_blank rel=noopener href=https://twitter.com/apachekafka aria-label=Twitter><i class="fab fa-twitter"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Stack Overflow" aria-label="Stack Overflow"><a target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/apache-kafka aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/apache/kafka aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Developer mailing list" aria-label="Developer mailing list"><a target=_blank rel=noopener href=mailto:dev@kafka.apache.org aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2014&ndash;2025
<span class=td-footer__authors>By <a href=https://www.apache.org/>Apache Software Foundation</a> under the terms of the <a href=https://www.apache.org/licenses/LICENSE-2.0>Apache License v2</a></span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span><span class=ms-2><a href=https://privacy.apache.org/policies/privacy-policy-public.html target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.dc2c0119076a0df855e55a8044ce0de74b7b9033c20e853e22d7ec7e9bdde965.js integrity="sha256-3CwBGQdqDfhV5VqARM4N50t7kDPCDoU+Itfsfpvd6WU=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>
<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://example.kafka-site-md.dev/31/kafka-connect/><link rel=alternate type=application/rss+xml href=https://example.kafka-site-md.dev/31/kafka-connect/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Kafka Connect | </title><meta name=description content="Apache Kafka"><meta property="og:title" content="Kafka Connect"><meta property="og:description" content="Apache Kafka"><meta property="og:type" content="website"><meta property="og:url" content="https://example.kafka-site-md.dev/31/kafka-connect/"><meta itemprop=name content="Kafka Connect"><meta itemprop=description content="Apache Kafka"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kafka Connect"><meta name=twitter:description content="Apache Kafka"><link rel=preload href=/scss/main.min.7ed0eb3fc68a0678ca492e0db9c00f8e8d5b776bbb2fb833732191f6bbf02877.css as=style integrity="sha256-ftDrP8aKBnjKSS4NucAPjo1bd2u7L7gzcyGR9rvwKHc=" crossorigin=anonymous><link href=/scss/main.min.7ed0eb3fc68a0678ca492e0db9c00f8e8d5b776bbb2fb833732191f6bbf02877.css rel=stylesheet integrity="sha256-ftDrP8aKBnjKSS4NucAPjo1bd2u7L7gzcyGR9rvwKHc=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="154" height="250" viewBox="0 0 256 416" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M201.816 230.216c-16.186.0-30.697 7.171-40.634 18.461l-25.463-18.026c2.703-7.442 4.255-15.433 4.255-23.797.0-8.219-1.498-16.076-4.112-23.408l25.406-17.835c9.936 11.233 24.409 18.365 40.548 18.365 29.875.0 54.184-24.305 54.184-54.184.0-29.879-24.309-54.184-54.184-54.184s-54.184 24.305-54.184 54.184c0 5.348.808 10.505 2.258 15.389l-25.423 17.844c-10.62-13.175-25.911-22.374-43.333-25.182v-30.64c24.544-5.155 43.037-26.962 43.037-53.019C124.171 24.305 99.862.0 69.987.0 40.112.0 15.803 24.305 15.803 54.184c0 25.708 18.014 47.246 42.067 52.769v31.038C25.044 143.753.0 172.401.0 206.854c0 34.621 25.292 63.374 58.355 68.94v32.774c-24.299 5.341-42.552 27.011-42.552 52.894.0 29.879 24.309 54.184 54.184 54.184s54.184-24.305 54.184-54.184c0-25.883-18.253-47.553-42.552-52.894v-32.775a69.965 69.965.0 0042.6-24.776l25.633 18.143c-1.423 4.84-2.22 9.946-2.22 15.24.0 29.879 24.309 54.184 54.184 54.184S256 314.279 256 284.4c0-29.879-24.309-54.184-54.184-54.184zm0-126.695c14.487.0 26.27 11.788 26.27 26.271s-11.783 26.27-26.27 26.27-26.27-11.787-26.27-26.27 11.783-26.271 26.27-26.271zm-158.1-49.337c0-14.483 11.784-26.27 26.271-26.27s26.27 11.787 26.27 26.27c0 14.483-11.783 26.27-26.27 26.27s-26.271-11.787-26.271-26.27zm52.541 307.278c0 14.483-11.783 26.27-26.27 26.27s-26.271-11.787-26.271-26.27 11.784-26.27 26.271-26.27 26.27 11.787 26.27 26.27zm-26.272-117.97c-20.205.0-36.642-16.434-36.642-36.638.0-20.205 16.437-36.642 36.642-36.642 20.204.0 36.641 16.437 36.641 36.642.0 20.204-16.437 36.638-36.641 36.638zm131.831 67.179c-14.487.0-26.27-11.788-26.27-26.271s11.783-26.27 26.27-26.27 26.27 11.787 26.27 26.27-11.783 26.271-26.27 26.271z" style="fill:#231f20"/></svg></span><span class=navbar-brand__name></span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/41/><span>Documentation</span></a></li><li class=nav-item><a class=nav-link href=/blog/><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/community/><span>Community</span></a></li><li class=nav-item><a class=nav-link href=/testimonials/><span>Testimonials</span></a></li><li class=nav-item><a class=nav-link href=/community/downloads/><span>Download Kafka</span></a></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>Releases</a><ul class=dropdown-menu><li><a class=dropdown-item href=/41/>4.1</a></li><li><a class=dropdown-item href=/40/>4.0</a></li><li><a class=dropdown-item href=/39/>3.9</a></li><li><a class=dropdown-item href=/38/>3.8</a></li><li><a class=dropdown-item href=/37/>3.7</a></li><li><a class=dropdown-item href=/36/>3.6</a></li><li><a class=dropdown-item href=/35/>3.5</a></li><li><a class=dropdown-item href=/34/>3.4</a></li><li><a class=dropdown-item href=/33/>3.3</a></li><li><a class=dropdown-item href=/32/>3.2</a></li><li><a class=dropdown-item href=/31/>3.1</a></li><li><a class=dropdown-item href=/30/>3.0</a></li><li><a class=dropdown-item href=/28/>2.8</a></li><li><a class=dropdown-item href=/27/>2.7</a></li><li><a class=dropdown-item href=/26/>2.6</a></li><li><a class=dropdown-item href=/25/>2.5</a></li><li><a class=dropdown-item href=/24/>2.4</a></li><li><a class=dropdown-item href=/23/>2.3</a></li><li><a class=dropdown-item href=/22/>2.2</a></li><li><a class=dropdown-item href=/21/>2.1</a></li><li><a class=dropdown-item href=/20/>2.0</a></li><li><a class=dropdown-item href=/11/>1.1</a></li><li><a class=dropdown-item href=/10/>1.0</a></li><li><a class=dropdown-item href=/0110/>0.11.0</a></li><li><a class=dropdown-item href=/0102/>0.10.2</a></li><li><a class=dropdown-item href=/0101/>0.10.1</a></li><li><a class=dropdown-item href=/0100/>0.10.0</a></li><li><a class=dropdown-item href=/090/>0.9.0</a></li><li><a class=dropdown-item href=/082/>0.8.2</a></li><li><a class=dropdown-item href=/081/>0.8.1</a></li><li><a class=dropdown-item href=/080/>0.8.0</a></li><li><a class=dropdown-item href=/07/>0.7</a></li></ul></div></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.a770465805a0cb46ff1e57a8f55b44bc.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/31/kafka-connect/>Return to the regular view of this page</a>.</p></div><h1 class=title>Kafka Connect</h1><ul><li>1: <a href=#pg-c2659f289ddd7d21b5d550369f125536>Overview</a></li><li>2: <a href=#pg-46d1605146b63caa43216f4fccd34e47>User Guide</a></li><li>3: <a href=#pg-04c346c27a74ebaf6912532d5bb22d14>Connector Development Guide</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-c2659f289ddd7d21b5d550369f125536>1 - Overview</h1><div class=lead>Overview</div><h1 id=overview>Overview<a class=td-heading-self-link href=#overview aria-label="Heading self-link"></a></h1><p>Kafka Connect is a tool for scalably and reliably streaming data between Apache Kafka and other systems. It makes it simple to quickly define <em>connectors</em> that move large collections of data into and out of Kafka. Kafka Connect can ingest entire databases or collect metrics from all your application servers into Kafka topics, making the data available for stream processing with low latency. An export job can deliver data from Kafka topics into secondary storage and query systems or into batch systems for offline analysis.</p><p>Kafka Connect features include:</p><ul><li><strong>A common framework for Kafka connectors</strong> - Kafka Connect standardizes integration of other data systems with Kafka, simplifying connector development, deployment, and management</li><li><strong>Distributed and standalone modes</strong> - scale up to a large, centrally managed service supporting an entire organization or scale down to development, testing, and small production deployments</li><li><strong>REST interface</strong> - submit and manage connectors to your Kafka Connect cluster via an easy to use REST API</li><li><strong>Automatic offset management</strong> - with just a little information from connectors, Kafka Connect can manage the offset commit process automatically so connector developers do not need to worry about this error prone part of connector development</li><li><strong>Distributed and scalable by default</strong> - Kafka Connect builds on the existing group management protocol. More workers can be added to scale up a Kafka Connect cluster.</li><li><strong>Streaming/batch integration</strong> - leveraging Kafka&rsquo;s existing capabilities, Kafka Connect is an ideal solution for bridging streaming and batch data systems</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-46d1605146b63caa43216f4fccd34e47>2 - User Guide</h1><div class=lead>User Guide</div><h1 id=user-guide>User Guide<a class=td-heading-self-link href=#user-guide aria-label="Heading self-link"></a></h1><p>The <a href=../quickstart>quickstart</a> provides a brief example of how to run a standalone version of Kafka Connect. This section describes how to configure, run, and manage Kafka Connect in more detail.</p><h2 id=running-kafka-connect>Running Kafka Connect<a class=td-heading-self-link href=#running-kafka-connect aria-label="Heading self-link"></a></h2><p>Kafka Connect currently supports two modes of execution: standalone (single process) and distributed.</p><p>In standalone mode all work is performed in a single process. This configuration is simpler to setup and get started with and may be useful in situations where only one worker makes sense (e.g. collecting log files), but it does not benefit from some of the features of Kafka Connect such as fault tolerance. You can start a standalone process with the following command:</p><pre><code>    &gt; bin/connect-standalone.sh config/connect-standalone.properties connector1.properties [connector2.properties ...]
</code></pre><p>The first parameter is the configuration for the worker. This includes settings such as the Kafka connection parameters, serialization format, and how frequently to commit offsets. The provided example should work well with a local cluster running with the default configuration provided by <code>config/server.properties</code>. It will require tweaking to use with a different configuration or production deployment. All workers (both standalone and distributed) require a few configs:</p><ul><li><code>bootstrap.servers</code> - List of Kafka servers used to bootstrap connections to Kafka</li><li><code>key.converter</code> - Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the keys in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.</li><li><code>value.converter</code> - Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the values in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.</li><li><code>plugin.path</code> (default <code>empty</code>) - a list of paths that contain Connect plugins (connectors, converters, transformations). Before running quick starts, users must add the absolute path that contains the example FileStreamSourceConnector and FileStreamSinkConnector packaged in <code>connect-file-"version".jar</code>, because these connectors are not included by default to the <code>CLASSPATH</code> or the <code>plugin.path</code> of the Connect worker (see plugin.path property for examples).</li></ul><p>The important configuration options specific to standalone mode are:</p><ul><li><code>offset.storage.file.filename</code> - File to store offset data in</li></ul><p>The parameters that are configured here are intended for producers and consumers used by Kafka Connect to access the configuration, offset and status topics. For configuration of the producers used by Kafka source tasks and the consumers used by Kafka sink tasks, the same parameters can be used but need to be prefixed with <code>producer.</code> and <code>consumer.</code> respectively. The only Kafka client parameter that is inherited without a prefix from the worker configuration is <code>bootstrap.servers</code>, which in most cases will be sufficient, since the same cluster is often used for all purposes. A notable exception is a secured cluster, which requires extra parameters to allow connections. These parameters will need to be set up to three times in the worker configuration, once for management access, once for Kafka sources and once for Kafka sinks.</p><p>Starting with 2.3.0, client configuration overrides can be configured individually per connector by using the prefixes <code>producer.override.</code> and <code>consumer.override.</code> for Kafka sources or Kafka sinks respectively. These overrides are included with the rest of the connector&rsquo;s configuration properties.</p><p>The remaining parameters are connector configuration files. You may include as many as you want, but all will execute within the same process (on different threads).</p><p>Distributed mode handles automatic balancing of work, allows you to scale up (or down) dynamically, and offers fault tolerance both in the active tasks and for configuration and offset commit data. Execution is very similar to standalone mode:</p><pre><code>    &gt; bin/connect-distributed.sh config/connect-distributed.properties
</code></pre><p>The difference is in the class which is started and the configuration parameters which change how the Kafka Connect process decides where to store configurations, how to assign work, and where to store offsets and task statues. In the distributed mode, Kafka Connect stores the offsets, configs and task statuses in Kafka topics. It is recommended to manually create the topics for offset, configs and statuses in order to achieve the desired the number of partitions and replication factors. If the topics are not yet created when starting Kafka Connect, the topics will be auto created with default number of partitions and replication factor, which may not be best suited for its usage.</p><p>In particular, the following configuration parameters, in addition to the common settings mentioned above, are critical to set before starting your cluster:</p><ul><li><code>group.id</code> (default <code>connect-cluster</code>) - unique name for the cluster, used in forming the Connect cluster group; note that this <strong>must not conflict</strong> with consumer group IDs</li><li><code>config.storage.topic</code> (default <code>connect-configs</code>) - topic to use for storing connector and task configurations; note that this should be a single partition, highly replicated, compacted topic. You may need to manually create the topic to ensure the correct configuration as auto created topics may have multiple partitions or be automatically configured for deletion rather than compaction</li><li><code>offset.storage.topic</code> (default <code>connect-offsets</code>) - topic to use for storing offsets; this topic should have many partitions, be replicated, and be configured for compaction</li><li><code>status.storage.topic</code> (default <code>connect-status</code>) - topic to use for storing statuses; this topic can have multiple partitions, and should be replicated and configured for compaction</li></ul><p>Note that in distributed mode the connector configurations are not passed on the command line. Instead, use the REST API described below to create, modify, and destroy connectors.</p><h2 id=configuring-connectors>Configuring Connectors<a class=td-heading-self-link href=#configuring-connectors aria-label="Heading self-link"></a></h2><p>Connector configurations are simple key-value mappings. For standalone mode these are defined in a properties file and passed to the Connect process on the command line. In distributed mode, they will be included in the JSON payload for the request that creates (or modifies) the connector.</p><p>Most configurations are connector dependent, so they can&rsquo;t be outlined here. However, there are a few common options:</p><ul><li><code>name</code> - Unique name for the connector. Attempting to register again with the same name will fail.</li><li><code>connector.class</code> - The Java class for the connector</li><li><code>tasks.max</code> - The maximum number of tasks that should be created for this connector. The connector may create fewer tasks if it cannot achieve this level of parallelism.</li><li><code>key.converter</code> - (optional) Override the default key converter set by the worker.</li><li><code>value.converter</code> - (optional) Override the default value converter set by the worker.</li></ul><p>The <code>connector.class</code> config supports several formats: the full name or alias of the class for this connector. If the connector is org.apache.kafka.connect.file.FileStreamSinkConnector, you can either specify this full name or use FileStreamSink or FileStreamSinkConnector to make the configuration a bit shorter.</p><p>Sink connectors also have a few additional options to control their input. Each sink connector must set one of the following:</p><ul><li><code>topics</code> - A comma-separated list of topics to use as input for this connector</li><li><code>topics.regex</code> - A Java regular expression of topics to use as input for this connector</li></ul><p>For any other options, you should consult the documentation for the connector.</p><h2 id=transformations>Transformations<a class=td-heading-self-link href=#transformations aria-label="Heading self-link"></a></h2><p>Connectors can be configured with transformations to make lightweight message-at-a-time modifications. They can be convenient for data massaging and event routing.</p><p>A transformation chain can be specified in the connector configuration.</p><ul><li><code>transforms</code> - List of aliases for the transformation, specifying the order in which the transformations will be applied.</li><li><code>transforms.$alias.type</code> - Fully qualified class name for the transformation.</li><li><code>transforms.$alias.$transformationSpecificConfig</code> Configuration properties for the transformation</li></ul><p>For example, lets take the built-in file source connector and use a transformation to add a static field.</p><p>Throughout the example we&rsquo;ll use schemaless JSON data format. To use schemaless format, we changed the following two lines in <code>connect-standalone.properties</code> from true to false:</p><pre><code>        key.converter.schemas.enable
        value.converter.schemas.enable
</code></pre><p>The file source connector reads each line as a String. We will wrap each line in a Map and then add a second field to identify the origin of the event. To do this, we use two transformations:</p><ul><li><strong>HoistField</strong> to place the input line inside a Map</li><li><strong>InsertField</strong> to add the static field. In this example we&rsquo;ll indicate that the record came from a file connector</li></ul><p>After adding the transformations, <code>connect-file-source.properties</code> file looks as following:</p><pre><code>        name=local-file-source
        connector.class=FileStreamSource
        tasks.max=1
        file=test.txt
        topic=connect-test
        transforms=MakeMap, InsertSource
        transforms.MakeMap.type=org.apache.kafka.connect.transforms.HoistField$Value
        transforms.MakeMap.field=line
        transforms.InsertSource.type=org.apache.kafka.connect.transforms.InsertField$Value
        transforms.InsertSource.static.field=data_source
        transforms.InsertSource.static.value=test-file-source
</code></pre><p>All the lines starting with <code>transforms</code> were added for the transformations. You can see the two transformations we created: &ldquo;InsertSource&rdquo; and &ldquo;MakeMap&rdquo; are aliases that we chose to give the transformations. The transformation types are based on the list of built-in transformations you can see below. Each transformation type has additional configuration: HoistField requires a configuration called &ldquo;field&rdquo;, which is the name of the field in the map that will include the original String from the file. InsertField transformation lets us specify the field name and the value that we are adding.</p><p>When we ran the file source connector on my sample file without the transformations, and then read them using <code>kafka-console-consumer.sh</code>, the results were:</p><pre><code>        &quot;foo&quot;
        &quot;bar&quot;
        &quot;hello world&quot;
</code></pre><p>We then create a new file connector, this time after adding the transformations to the configuration file. This time, the results will be:</p><pre><code>        {&quot;line&quot;:&quot;foo&quot;,&quot;data_source&quot;:&quot;test-file-source&quot;}
        {&quot;line&quot;:&quot;bar&quot;,&quot;data_source&quot;:&quot;test-file-source&quot;}
        {&quot;line&quot;:&quot;hello world&quot;,&quot;data_source&quot;:&quot;test-file-source&quot;}
</code></pre><p>You can see that the lines we&rsquo;ve read are now part of a JSON map, and there is an extra field with the static value we specified. This is just one example of what you can do with transformations.</p><h3 id=included-transformations>Included transformations<a class=td-heading-self-link href=#included-transformations aria-label="Heading self-link"></a></h3><p>Several widely-applicable data and routing transformations are included with Kafka Connect:</p><ul><li>InsertField - Add a field using either static data or record metadata</li><li>ReplaceField - Filter or rename fields</li><li>MaskField - Replace field with valid null value for the type (0, empty string, etc) or custom replacement (non-empty string or numeric value only)</li><li>ValueToKey - Replace the record key with a new key formed from a subset of fields in the record value</li><li>HoistField - Wrap the entire event as a single field inside a Struct or a Map</li><li>ExtractField - Extract a specific field from Struct and Map and include only this field in results</li><li>SetSchemaMetadata - modify the schema name or version</li><li>TimestampRouter - Modify the topic of a record based on original topic and timestamp. Useful when using a sink that needs to write to different tables or indexes based on timestamps</li><li>RegexRouter - modify the topic of a record based on original topic, replacement string and a regular expression</li><li>Filter - Removes messages from all further processing. This is used with a predicate to selectively filter certain messages.</li><li>InsertHeader - Add a header using static data</li><li>HeadersFrom - Copy or move fields in the key or value to the record headers</li><li>DropHeaders - Remove headers by name</li></ul><p>Details on how to configure each transformation are listed below:</p><div id=org.apache.kafka.connect.transforms.InsertField><h5>org.apache.kafka.connect.transforms.InsertField</h5>Insert field(s) using attributes from the record metadata or a configured static value.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.InsertField$Key</code>) or value (<code>org.apache.kafka.connect.transforms.InsertField$Value</code>).<p><ul class=config-list><li><h6><a id=offset.field></a><a id=org.apache.kafka.connect.transforms.InsertField_offset.field href=#org.apache.kafka.connect.transforms.InsertField_offset.field>offset.field</a></h6><p>Field name for Kafka offset - only applicable to sink connectors.<br>Suffix with <code>!</code> to make this a required field, or <code>?</code> to keep it optional (the default).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=partition.field></a><a id=org.apache.kafka.connect.transforms.InsertField_partition.field href=#org.apache.kafka.connect.transforms.InsertField_partition.field>partition.field</a></h6><p>Field name for Kafka partition. Suffix with <code>!</code> to make this a required field, or <code>?</code> to keep it optional (the default).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=static.field></a><a id=org.apache.kafka.connect.transforms.InsertField_static.field href=#org.apache.kafka.connect.transforms.InsertField_static.field>static.field</a></h6><p>Field name for static data field. Suffix with <code>!</code> to make this a required field, or <code>?</code> to keep it optional (the default).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=static.value></a><a id=org.apache.kafka.connect.transforms.InsertField_static.value href=#org.apache.kafka.connect.transforms.InsertField_static.value>static.value</a></h6><p>Static field value, if field name configured.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=timestamp.field></a><a id=org.apache.kafka.connect.transforms.InsertField_timestamp.field href=#org.apache.kafka.connect.transforms.InsertField_timestamp.field>timestamp.field</a></h6><p>Field name for record timestamp. Suffix with <code>!</code> to make this a required field, or <code>?</code> to keep it optional (the default).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=topic.field></a><a id=org.apache.kafka.connect.transforms.InsertField_topic.field href=#org.apache.kafka.connect.transforms.InsertField_topic.field>topic.field</a></h6><p>Field name for Kafka topic. Suffix with <code>!</code> to make this a required field, or <code>?</code> to keep it optional (the default).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.ReplaceField><h5>org.apache.kafka.connect.transforms.ReplaceField</h5>Filter or rename fields.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.ReplaceField$Key</code>) or value (<code>org.apache.kafka.connect.transforms.ReplaceField$Value</code>).<p><ul class=config-list><li><h6><a id=exclude></a><a id=org.apache.kafka.connect.transforms.ReplaceField_exclude href=#org.apache.kafka.connect.transforms.ReplaceField_exclude>exclude</a></h6><p>Fields to exclude. This takes precedence over the fields to include.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td>""</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=include></a><a id=org.apache.kafka.connect.transforms.ReplaceField_include href=#org.apache.kafka.connect.transforms.ReplaceField_include>include</a></h6><p>Fields to include. If specified, only these fields will be used.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td>""</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=renames></a><a id=org.apache.kafka.connect.transforms.ReplaceField_renames href=#org.apache.kafka.connect.transforms.ReplaceField_renames>renames</a></h6><p>Field rename mappings.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td>""</td></tr><tr><th>Valid Values:</th><td>list of colon-delimited pairs, e.g. <code>foo:bar,abc:xyz</code></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li><li><h6><a id=blacklist></a><a id=org.apache.kafka.connect.transforms.ReplaceField_blacklist href=#org.apache.kafka.connect.transforms.ReplaceField_blacklist>blacklist</a></h6><p>Deprecated. Use exclude instead.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>low</td></tr></tbody></table></li><li><h6><a id=whitelist></a><a id=org.apache.kafka.connect.transforms.ReplaceField_whitelist href=#org.apache.kafka.connect.transforms.ReplaceField_whitelist>whitelist</a></h6><p>Deprecated. Use include instead.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>low</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.MaskField><h5>org.apache.kafka.connect.transforms.MaskField</h5>Mask specified fields with a valid null value for the field type (i.e. 0, false, empty string, and so on).<p>For numeric and string fields, an optional replacement value can be specified that is converted to the correct type.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.MaskField$Key</code>) or value (<code>org.apache.kafka.connect.transforms.MaskField$Value</code>).<p><ul class=config-list><li><h6><a id=fields></a><a id=org.apache.kafka.connect.transforms.MaskField_fields href=#org.apache.kafka.connect.transforms.MaskField_fields>fields</a></h6><p>Names of fields to mask.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty list</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=replacement></a><a id=org.apache.kafka.connect.transforms.MaskField_replacement href=#org.apache.kafka.connect.transforms.MaskField_replacement>replacement</a></h6><p>Custom value replacement, that will be applied to all 'fields' values (numeric or non-empty string values only).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td>non-empty string</td></tr><tr><th>Importance:</th><td>low</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.ValueToKey><h5>org.apache.kafka.connect.transforms.ValueToKey</h5>Replace the record key with a new key formed from a subset of fields in the record value.<p><ul class=config-list><li><h6><a id=fields></a><a id=org.apache.kafka.connect.transforms.ValueToKey_fields href=#org.apache.kafka.connect.transforms.ValueToKey_fields>fields</a></h6><p>Field names on the record value to extract as the record key.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty list</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.HoistField><h5>org.apache.kafka.connect.transforms.HoistField</h5>Wrap data using the specified field name in a Struct when schema present, or a Map in the case of schemaless data.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.HoistField$Key</code>) or value (<code>org.apache.kafka.connect.transforms.HoistField$Value</code>).<p><ul class=config-list><li><h6><a id=field></a><a id=org.apache.kafka.connect.transforms.HoistField_field href=#org.apache.kafka.connect.transforms.HoistField_field>field</a></h6><p>Field name for the single field that will be created in the resulting Struct or Map.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.ExtractField><h5>org.apache.kafka.connect.transforms.ExtractField</h5>Extract the specified field from a Struct when schema present, or a Map in the case of schemaless data. Any null values are passed through unmodified.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.ExtractField$Key</code>) or value (<code>org.apache.kafka.connect.transforms.ExtractField$Value</code>).<p><ul class=config-list><li><h6><a id=field></a><a id=org.apache.kafka.connect.transforms.ExtractField_field href=#org.apache.kafka.connect.transforms.ExtractField_field>field</a></h6><p>Field name to extract.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.SetSchemaMetadata><h5>org.apache.kafka.connect.transforms.SetSchemaMetadata</h5>Set the schema name, version or both on the record's key (<code>org.apache.kafka.connect.transforms.SetSchemaMetadata$Key</code>) or value (<code>org.apache.kafka.connect.transforms.SetSchemaMetadata$Value</code>) schema.<p><ul class=config-list><li><h6><a id=schema.name></a><a id=org.apache.kafka.connect.transforms.SetSchemaMetadata_schema.name href=#org.apache.kafka.connect.transforms.SetSchemaMetadata_schema.name>schema.name</a></h6><p>Schema name to set.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=schema.version></a><a id=org.apache.kafka.connect.transforms.SetSchemaMetadata_schema.version href=#org.apache.kafka.connect.transforms.SetSchemaMetadata_schema.version>schema.version</a></h6><p>Schema version to set.</p><table><tbody><tr><th>Type:</th><td>int</td></tr><tr><th>Default:</th><td>null</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.TimestampRouter><h5>org.apache.kafka.connect.transforms.TimestampRouter</h5>Update the record's topic field as a function of the original topic value and the record timestamp.<p>This is mainly useful for sink connectors, since the topic field is often used to determine the equivalent entity name in the destination system(e.g. database table or search index name).<p><ul class=config-list><li><h6><a id=timestamp.format></a><a id=org.apache.kafka.connect.transforms.TimestampRouter_timestamp.format href=#org.apache.kafka.connect.transforms.TimestampRouter_timestamp.format>timestamp.format</a></h6><p>Format string for the timestamp that is compatible with <code>java.text.SimpleDateFormat</code>.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>yyyyMMdd</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=topic.format></a><a id=org.apache.kafka.connect.transforms.TimestampRouter_topic.format href=#org.apache.kafka.connect.transforms.TimestampRouter_topic.format>topic.format</a></h6><p>Format string which can contain <code>${topic}</code> and <code>${timestamp}</code> as placeholders for the topic and timestamp, respectively.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>${topic}-${timestamp}</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.RegexRouter><h5>org.apache.kafka.connect.transforms.RegexRouter</h5>Update the record topic using the configured regular expression and replacement string.<p>Under the hood, the regex is compiled to a <code>java.util.regex.Pattern</code>. If the pattern matches the input topic, <code>java.util.regex.Matcher#replaceFirst()</code> is used with the replacement string to obtain the new topic.<p><ul class=config-list><li><h6><a id=regex></a><a id=org.apache.kafka.connect.transforms.RegexRouter_regex href=#org.apache.kafka.connect.transforms.RegexRouter_regex>regex</a></h6><p>Regular expression to use for matching.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>valid regex</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=replacement></a><a id=org.apache.kafka.connect.transforms.RegexRouter_replacement href=#org.apache.kafka.connect.transforms.RegexRouter_replacement>replacement</a></h6><p>Replacement string.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.Flatten><h5>org.apache.kafka.connect.transforms.Flatten</h5>Flatten a nested data structure, generating names for each field by concatenating the field names at each level with a configurable delimiter character. Applies to Struct when schema present, or a Map in the case of schemaless data. Array fields and their contents are not modified. The default delimiter is '.'.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.Flatten$Key</code>) or value (<code>org.apache.kafka.connect.transforms.Flatten$Value</code>).<p><ul class=config-list><li><h6><a id=delimiter></a><a id=org.apache.kafka.connect.transforms.Flatten_delimiter href=#org.apache.kafka.connect.transforms.Flatten_delimiter>delimiter</a></h6><p>Delimiter to insert between field names from the input record when generating field names for the output record</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>.</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.Cast><h5>org.apache.kafka.connect.transforms.Cast</h5>Cast fields or the entire key or value to a specific type, e.g. to force an integer field to a smaller width. Cast from integers, floats, boolean and string to any other type, and cast binary to string (base64 encoded).<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.Cast$Key</code>) or value (<code>org.apache.kafka.connect.transforms.Cast$Value</code>).<p><ul class=config-list><li><h6><a id=spec></a><a id=org.apache.kafka.connect.transforms.Cast_spec href=#org.apache.kafka.connect.transforms.Cast_spec>spec</a></h6><p>List of fields and the type to cast them to of the form field1:type,field2:type to cast fields of Maps or Structs. A single type to cast the entire value. Valid types are int8, int16, int32, int64, float32, float64, boolean, and string. Note that binary fields can only be cast to string.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>list of colon-delimited pairs, e.g. <code>foo:bar,abc:xyz</code></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.TimestampConverter><h5>org.apache.kafka.connect.transforms.TimestampConverter</h5>Convert timestamps between different formats such as Unix epoch, strings, and Connect Date/Timestamp types.Applies to individual fields or to the entire value.<p>Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.TimestampConverter$Key</code>) or value (<code>org.apache.kafka.connect.transforms.TimestampConverter$Value</code>).<p><ul class=config-list><li><h6><a id=target.type></a><a id=org.apache.kafka.connect.transforms.TimestampConverter_target.type href=#org.apache.kafka.connect.transforms.TimestampConverter_target.type>target.type</a></h6><p>The desired timestamp representation: string, unix, Date, Time, or Timestamp</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=field></a><a id=org.apache.kafka.connect.transforms.TimestampConverter_field href=#org.apache.kafka.connect.transforms.TimestampConverter_field>field</a></h6><p>The field containing the timestamp, or empty if the entire value is a timestamp</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>""</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=format></a><a id=org.apache.kafka.connect.transforms.TimestampConverter_format href=#org.apache.kafka.connect.transforms.TimestampConverter_format>format</a></h6><p>A SimpleDateFormat-compatible format for the timestamp. Used to generate the output when type=string or used to parse the input if the input is a string.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td>""</td></tr><tr><th>Valid Values:</th><td></td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.Filter><h5>org.apache.kafka.connect.transforms.Filter</h5>Drops all records, filtering them from subsequent transformations in the chain. This is intended to be used conditionally to filter out records matching (or not matching) a particular Predicate.<p><ul class=config-list></ul></div><div id=org.apache.kafka.connect.transforms.InsertHeader><h5>org.apache.kafka.connect.transforms.InsertHeader</h5>Add a header to each record.<p><ul class=config-list><li><h6><a id=header></a><a id=org.apache.kafka.connect.transforms.InsertHeader_header href=#org.apache.kafka.connect.transforms.InsertHeader_header>header</a></h6><p>The name of the header.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-null string</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=value.literal></a><a id=org.apache.kafka.connect.transforms.InsertHeader_value.literal href=#org.apache.kafka.connect.transforms.InsertHeader_value.literal>value.literal</a></h6><p>The literal value that is to be set as the header value on all records.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-null string</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.DropHeaders><h5>org.apache.kafka.connect.transforms.DropHeaders</h5>Removes one or more headers from each record.<p><ul class=config-list><li><h6><a id=headers></a><a id=org.apache.kafka.connect.transforms.DropHeaders_headers href=#org.apache.kafka.connect.transforms.DropHeaders_headers>headers</a></h6><p>The name of the headers to be removed.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty list</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.HeaderFrom><h5>org.apache.kafka.connect.transforms.HeaderFrom</h5>Moves or copies fields in the key/value of a record into that record's headers. Corresponding elements of <code>fields</code> and <code>headers</code> together identify a field and the header it should be moved or copied to. Use the concrete transformation type designed for the record key (<code>org.apache.kafka.connect.transforms.HeaderFrom$Key</code>) or value (<code>org.apache.kafka.connect.transforms.HeaderFrom$Value</code>).<p><ul class=config-list><li><h6><a id=fields></a><a id=org.apache.kafka.connect.transforms.HeaderFrom_fields href=#org.apache.kafka.connect.transforms.HeaderFrom_fields>fields</a></h6><p>Field names in the record whose values are to be copied or moved to headers.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty list</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=headers></a><a id=org.apache.kafka.connect.transforms.HeaderFrom_headers href=#org.apache.kafka.connect.transforms.HeaderFrom_headers>headers</a></h6><p>Header names, in the same order as the field names listed in the fields configuration property.</p><table><tbody><tr><th>Type:</th><td>list</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty list</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li><li><h6><a id=operation></a><a id=org.apache.kafka.connect.transforms.HeaderFrom_operation href=#org.apache.kafka.connect.transforms.HeaderFrom_operation>operation</a></h6><p>Either <code>move</code> if the fields are to be moved to the headers (removed from the key/value), or <code>copy</code> if the fields are to be copied to the headers (retained in the key/value).</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>[move, copy]</td></tr><tr><th>Importance:</th><td>high</td></tr></tbody></table></li></ul></div><h3 id=predicates>Predicates<a class=td-heading-self-link href=#predicates aria-label="Heading self-link"></a></h3><p>Transformations can be configured with predicates so that the transformation is applied only to messages which satisfy some condition. In particular, when combined with the <strong>Filter</strong> transformation predicates can be used to selectively filter out certain messages.</p><p>Predicates are specified in the connector configuration.</p><ul><li><code>predicates</code> - Set of aliases for the predicates to be applied to some of the transformations.</li><li><code>predicates.$alias.type</code> - Fully qualified class name for the predicate.</li><li><code>predicates.$alias.$predicateSpecificConfig</code> - Configuration properties for the predicate.</li></ul><p>All transformations have the implicit config properties <code>predicate</code> and <code>negate</code>. A predicular predicate is associated with a transformation by setting the transformation&rsquo;s <code>predicate</code> config to the predicate&rsquo;s alias. The predicate&rsquo;s value can be reversed using the <code>negate</code> configuration property.</p><p>For example, suppose you have a source connector which produces messages to many different topics and you want to:</p><ul><li>filter out the messages in the &lsquo;foo&rsquo; topic entirely</li><li>apply the ExtractField transformation with the field name &lsquo;other_field&rsquo; to records in all topics <em>except</em> the topic &lsquo;bar&rsquo;</li></ul><p>To do this we need first to filter out the records destined for the topic &lsquo;foo&rsquo;. The Filter transformation removes records from further processing, and can use the TopicNameMatches predicate to apply the transformation only to records in topics which match a certain regular expression. TopicNameMatches&rsquo;s only configuration property is <code>pattern</code> which is a Java regular expression for matching against the topic name. The configuration would look like this:</p><pre><code>        transforms=Filter
        transforms.Filter.type=org.apache.kafka.connect.transforms.Filter
        transforms.Filter.predicate=IsFoo

        predicates=IsFoo
        predicates.IsFoo.type=org.apache.kafka.connect.transforms.predicates.TopicNameMatches
        predicates.IsFoo.pattern=foo
</code></pre><p>Next we need to apply ExtractField only when the topic name of the record is not &lsquo;bar&rsquo;. We can&rsquo;t just use TopicNameMatches directly, because that would apply the transformation to matching topic names, not topic names which do <em>not</em> match. The transformation&rsquo;s implicit <code>negate</code> config properties allows us to invert the set of records which a predicate matches. Adding the configuration for this to the previous example we arrive at:</p><pre><code>        transforms=Filter,Extract
        transforms.Filter.type=org.apache.kafka.connect.transforms.Filter
        transforms.Filter.predicate=IsFoo

        transforms.Extract.type=org.apache.kafka.connect.transforms.ExtractField$Key
        transforms.Extract.field=other_field
        transforms.Extract.predicate=IsBar
        transforms.Extract.negate=true

        predicates=IsFoo,IsBar
        predicates.IsFoo.type=org.apache.kafka.connect.transforms.predicates.TopicNameMatches
        predicates.IsFoo.pattern=foo

        predicates.IsBar.type=org.apache.kafka.connect.transforms.predicates.TopicNameMatches
        predicates.IsBar.pattern=bar
</code></pre><p>Kafka Connect includes the following predicates:</p><ul><li><code>TopicNameMatches</code> - matches records in a topic with a name matching a particular Java regular expression.</li><li><code>HasHeaderKey</code> - matches records which have a header with the given key.</li><li><code>RecordIsTombstone</code> - matches tombstone records, that is records with a null value.</li></ul><p>Details on how to configure each predicate are listed below:</p><div id=org.apache.kafka.connect.transforms.predicates.HasHeaderKey><h5>org.apache.kafka.connect.transforms.predicates.HasHeaderKey</h5>A predicate which is true for records with at least one header with the configured name.<p><ul class=config-list><li><h6><a id=name></a><a id=org.apache.kafka.connect.transforms.predicates.HasHeaderKey_name href=#org.apache.kafka.connect.transforms.predicates.HasHeaderKey_name>name</a></h6><p>The header name.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty string</td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><div id=org.apache.kafka.connect.transforms.predicates.RecordIsTombstone><h5>org.apache.kafka.connect.transforms.predicates.RecordIsTombstone</h5>A predicate which is true for records which are tombstones (i.e. have null value).<p><ul class=config-list></ul></div><div id=org.apache.kafka.connect.transforms.predicates.TopicNameMatches><h5>org.apache.kafka.connect.transforms.predicates.TopicNameMatches</h5>A predicate which is true for records with a topic name that matches the configured regular expression.<p><ul class=config-list><li><h6><a id=pattern></a><a id=org.apache.kafka.connect.transforms.predicates.TopicNameMatches_pattern href=#org.apache.kafka.connect.transforms.predicates.TopicNameMatches_pattern>pattern</a></h6><p>A Java regular expression for matching against the name of a record's topic.</p><table><tbody><tr><th>Type:</th><td>string</td></tr><tr><th>Default:</th><td></td></tr><tr><th>Valid Values:</th><td>non-empty string, valid regex</td></tr><tr><th>Importance:</th><td>medium</td></tr></tbody></table></li></ul></div><h2 id=rest-api>REST API<a class=td-heading-self-link href=#rest-api aria-label="Heading self-link"></a></h2><p>Since Kafka Connect is intended to be run as a service, it also provides a REST API for managing connectors. The REST API server can be configured using the <code>listeners</code> configuration option. This field should contain a list of listeners in the following format: <code>protocol://host:port,protocol2://host2:port2</code>. Currently supported protocols are <code>http</code> and <code>https</code>. For example:</p><pre><code>        listeners=http://localhost:8080,https://localhost:8443
</code></pre><p>By default, if no <code>listeners</code> are specified, the REST server runs on port 8083 using the HTTP protocol. When using HTTPS, the configuration has to include the SSL configuration. By default, it will use the <code>ssl.*</code> settings. In case it is needed to use different configuration for the REST API than for connecting to Kafka brokers, the fields can be prefixed with <code>listeners.https</code>. When using the prefix, only the prefixed options will be used and the <code>ssl.*</code> options without the prefix will be ignored. Following fields can be used to configure HTTPS for the REST API:</p><ul><li><code>ssl.keystore.location</code></li><li><code>ssl.keystore.password</code></li><li><code>ssl.keystore.type</code></li><li><code>ssl.key.password</code></li><li><code>ssl.truststore.location</code></li><li><code>ssl.truststore.password</code></li><li><code>ssl.truststore.type</code></li><li><code>ssl.enabled.protocols</code></li><li><code>ssl.provider</code></li><li><code>ssl.protocol</code></li><li><code>ssl.cipher.suites</code></li><li><code>ssl.keymanager.algorithm</code></li><li><code>ssl.secure.random.implementation</code></li><li><code>ssl.trustmanager.algorithm</code></li><li><code>ssl.endpoint.identification.algorithm</code></li><li><code>ssl.client.auth</code></li></ul><p>The REST API is used not only by users to monitor / manage Kafka Connect. It is also used for the Kafka Connect cross-cluster communication. Requests received on the follower nodes REST API will be forwarded to the leader node REST API. In case the URI under which is given host reachable is different from the URI which it listens on, the configuration options <code>rest.advertised.host.name</code>, <code>rest.advertised.port</code> and <code>rest.advertised.listener</code> can be used to change the URI which will be used by the follower nodes to connect with the leader. When using both HTTP and HTTPS listeners, the <code>rest.advertised.listener</code> option can be also used to define which listener will be used for the cross-cluster communication. When using HTTPS for communication between nodes, the same <code>ssl.*</code> or <code>listeners.https</code> options will be used to configure the HTTPS client.</p><p>The following are the currently supported REST API endpoints:</p><ul><li><code>GET /connectors</code> - return a list of active connectors</li><li><code>POST /connectors</code> - create a new connector; the request body should be a JSON object containing a string <code>name</code> field and an object <code>config</code> field with the connector configuration parameters</li><li><code>GET /connectors/{name}</code> - get information about a specific connector</li><li><code>GET /connectors/{name}/config</code> - get the configuration parameters for a specific connector</li><li><code>PUT /connectors/{name}/config</code> - update the configuration parameters for a specific connector</li><li><code>GET /connectors/{name}/status</code> - get current status of the connector, including if it is running, failed, paused, etc., which worker it is assigned to, error information if it has failed, and the state of all its tasks</li><li><code>GET /connectors/{name}/tasks</code> - get a list of tasks currently running for a connector</li><li><code>GET /connectors/{name}/tasks/{taskid}/status</code> - get current status of the task, including if it is running, failed, paused, etc., which worker it is assigned to, and error information if it has failed</li><li><code>PUT /connectors/{name}/pause</code> - pause the connector and its tasks, which stops message processing until the connector is resumed</li><li><code>PUT /connectors/{name}/resume</code> - resume a paused connector (or do nothing if the connector is not paused)</li><li><code>POST /connectors/{name}/restart?includeTasks=&lt;true|false>&amp;onlyFailed=&lt;true|false></code> - restart a connector and its tasks instances.<ul><li>the &ldquo;includeTasks&rdquo; parameter specifies whether to restart the connector instance and task instances (&ldquo;includeTasks=true&rdquo;) or just the connector instance (&ldquo;includeTasks=false&rdquo;), with the default (&ldquo;false&rdquo;) preserving the same behavior as earlier versions.</li><li>the &ldquo;onlyFailed&rdquo; parameter specifies whether to restart just the instances with a FAILED status (&ldquo;onlyFailed=true&rdquo;) or all instances (&ldquo;onlyFailed=false&rdquo;), with the default (&ldquo;false&rdquo;) preserving the same behavior as earlier versions.</li></ul></li><li><code>POST /connectors/{name}/tasks/{taskId}/restart</code> - restart an individual task (typically because it has failed)</li><li><code>DELETE /connectors/{name}</code> - delete a connector, halting all tasks and deleting its configuration</li><li><code>GET /connectors/{name}/topics</code> - get the set of topics that a specific connector is using since the connector was created or since a request to reset its set of active topics was issued</li><li><code>PUT /connectors/{name}/topics/reset</code> - send a request to empty the set of active topics of a connector</li></ul><p>Kafka Connect also provides a REST API for getting information about connector plugins:</p><ul><li><code>GET /connector-plugins</code>- return a list of connector plugins installed in the Kafka Connect cluster. Note that the API only checks for connectors on the worker that handles the request, which means you may see inconsistent results, especially during a rolling upgrade if you add new connector jars</li><li><code>PUT /connector-plugins/{connector-type}/config/validate</code> - validate the provided configuration values against the configuration definition. This API performs per config validation, returns suggested values and error messages during validation.</li></ul><p>The following is a supported REST request at the top-level (root) endpoint:</p><ul><li><code>GET /</code>- return basic information about the Kafka Connect cluster such as the version of the Connect worker that serves the REST request (including git commit ID of the source code) and the Kafka cluster ID that is connected to.</li></ul><p>The <code>admin.listeners</code> configuration can be used to configure admin REST APIs on Kafka Connect&rsquo;s REST API server. Similar to the <code>listeners</code> configuration, this field should contain a list of listeners in the following format: <code>protocol://host:port,protocol2://host2:port2</code>. Currently supported protocols are <code>http</code> and <code>https</code>. For example:</p><pre><code>admin.listeners=http://localhost:8080,https://localhost:8443
</code></pre><p>By default, if <code>admin.listeners</code> is not configured, the admin REST APIs will be available on the regular listeners.</p><p>The following are the currently supported admin REST API endpoints:</p><ul><li><code>GET /admin/loggers</code> - list the current loggers that have their levels explicitly set and their log levels</li><li><code>GET /admin/loggers/{name}</code> - get the log level for the specified logger</li><li><code>PUT /admin/loggers/{name}</code> - set the log level for the specified logger</li></ul><p>See <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-495%3A+Dynamically+Adjust+Log+Levels+in+Connect>KIP-495</a> for more details about the admin logger REST APIs.</p><h2 id=error-reporting-in-connect>Error Reporting in Connect<a class=td-heading-self-link href=#error-reporting-in-connect aria-label="Heading self-link"></a></h2><p>Kafka Connect provides error reporting to handle errors encountered along various stages of processing. By default, any error encountered during conversion or within transformations will cause the connector to fail. Each connector configuration can also enable tolerating such errors by skipping them, optionally writing each error and the details of the failed operation and problematic record (with various levels of detail) to the Connect application log. These mechanisms also capture errors when a sink connector is processing the messages consumed from its Kafka topics, and all of the errors can be written to a configurable &ldquo;dead letter queue&rdquo; (DLQ) Kafka topic.</p><p>To report errors within a connector&rsquo;s converter, transforms, or within the sink connector itself to the log, set <code>errors.log.enable=true</code> in the connector configuration to log details of each error and problem record&rsquo;s topic, partition, and offset. For additional debugging purposes, set <code>errors.log.include.messages=true</code> to also log the problem record key, value, and headers to the log (note this may log sensitive information).</p><p>To report errors within a connector&rsquo;s converter, transforms, or within the sink connector itself to a dead letter queue topic, set <code>errors.deadletterqueue.topic.name</code>, and optionally <code>errors.deadletterqueue.context.headers.enable=true</code>.</p><p>By default connectors exhibit &ldquo;fail fast&rdquo; behavior immediately upon an error or exception. This is equivalent to adding the following configuration properties with their defaults to a connector configuration:</p><pre><code>        # disable retries on failure
        errors.retry.timeout=0

        # do not log the error and their contexts
        errors.log.enable=false

        # do not record errors in a dead letter queue topic
        errors.deadletterqueue.topic.name=

        # Fail on first error
        errors.tolerance=none
</code></pre><p>These and other related connector configuration properties can be changed to provide different behavior. For example, the following configuration properties can be added to a connector configuration to setup error handling with multiple retries, logging to the application logs and the <code>my-connector-errors</code> Kafka topic, and tolerating all errors by reporting them rather than failing the connector task:</p><pre><code>        # retry for at most 10 minutes times waiting up to 30 seconds between consecutive failures
        errors.retry.timeout=600000
        errors.retry.delay.max.ms=30000

        # log error context along with application logs, but do not include configs and messages
        errors.log.enable=true
        errors.log.include.messages=false

        # produce error context into the Kafka topic
        errors.deadletterqueue.topic.name=my-connector-errors

        # Tolerate all errors.
        errors.tolerance=all
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-04c346c27a74ebaf6912532d5bb22d14>3 - Connector Development Guide</h1><div class=lead>Connector Development Guide</div><h1 id=connector-development-guide>Connector Development Guide<a class=td-heading-self-link href=#connector-development-guide aria-label="Heading self-link"></a></h1><p>This guide describes how developers can write new connectors for Kafka Connect to move data between Kafka and other systems. It briefly reviews a few key concepts and then describes how to create a simple connector.</p><h2 id=core-concepts-and-apis>Core Concepts and APIs<a class=td-heading-self-link href=#core-concepts-and-apis aria-label="Heading self-link"></a></h2><h3 id=connectors-and-tasks>Connectors and Tasks<a class=td-heading-self-link href=#connectors-and-tasks aria-label="Heading self-link"></a></h3><p>To copy data between Kafka and another system, users create a <code>Connector</code> for the system they want to pull data from or push data to. Connectors come in two flavors: <code>SourceConnectors</code> import data from another system (e.g. <code>JDBCSourceConnector</code> would import a relational database into Kafka) and <code>SinkConnectors</code> export data (e.g. <code>HDFSSinkConnector</code> would export the contents of a Kafka topic to an HDFS file).</p><p><code>Connectors</code> do not perform any data copying themselves: their configuration describes the data to be copied, and the <code>Connector</code> is responsible for breaking that job into a set of <code>Tasks</code> that can be distributed to workers. These <code>Tasks</code> also come in two corresponding flavors: <code>SourceTask</code> and <code>SinkTask</code>.</p><p>With an assignment in hand, each <code>Task</code> must copy its subset of the data to or from Kafka. In Kafka Connect, it should always be possible to frame these assignments as a set of input and output streams consisting of records with consistent schemas. Sometimes this mapping is obvious: each file in a set of log files can be considered a stream with each parsed line forming a record using the same schema and offsets stored as byte offsets in the file. In other cases it may require more effort to map to this model: a JDBC connector can map each table to a stream, but the offset is less clear. One possible mapping uses a timestamp column to generate queries incrementally returning new data, and the last queried timestamp can be used as the offset.</p><h3 id=streams-and-records>Streams and Records<a class=td-heading-self-link href=#streams-and-records aria-label="Heading self-link"></a></h3><p>Each stream should be a sequence of key-value records. Both the keys and values can have complex structure &ndash; many primitive types are provided, but arrays, objects, and nested data structures can be represented as well. The runtime data format does not assume any particular serialization format; this conversion is handled internally by the framework.</p><p>In addition to the key and value, records (both those generated by sources and those delivered to sinks) have associated stream IDs and offsets. These are used by the framework to periodically commit the offsets of data that have been processed so that in the event of failures, processing can resume from the last committed offsets, avoiding unnecessary reprocessing and duplication of events.</p><h3 id=dynamic-connectors>Dynamic Connectors<a class=td-heading-self-link href=#dynamic-connectors aria-label="Heading self-link"></a></h3><p>Not all jobs are static, so <code>Connector</code> implementations are also responsible for monitoring the external system for any changes that might require reconfiguration. For example, in the <code>JDBCSourceConnector</code> example, the <code>Connector</code> might assign a set of tables to each <code>Task</code>. When a new table is created, it must discover this so it can assign the new table to one of the <code>Tasks</code> by updating its configuration. When it notices a change that requires reconfiguration (or a change in the number of <code>Tasks</code>), it notifies the framework and the framework updates any corresponding <code>Tasks</code>.</p><h2 id=developing-a-simple-connector>Developing a Simple Connector<a class=td-heading-self-link href=#developing-a-simple-connector aria-label="Heading self-link"></a></h2><p>Developing a connector only requires implementing two interfaces, the <code>Connector</code> and <code>Task</code>. A simple example is included with the source code for Kafka in the <code>file</code> package. This connector is meant for use in standalone mode and has implementations of a <code>SourceConnector</code>/<code>SourceTask</code> to read each line of a file and emit it as a record and a <code>SinkConnector</code>/<code>SinkTask</code> that writes each record to a file.</p><p>The rest of this section will walk through some code to demonstrate the key steps in creating a connector, but developers should also refer to the full example source code as many details are omitted for brevity.</p><h3 id=connector-example>Connector Example<a class=td-heading-self-link href=#connector-example aria-label="Heading self-link"></a></h3><p>We&rsquo;ll cover the <code>SourceConnector</code> as a simple example. <code>SinkConnector</code> implementations are very similar. Start by creating the class that inherits from <code>SourceConnector</code> and add a couple of fields that will store parsed configuration information (the filename to read from and the topic to send data to):</p><pre><code>    public class FileStreamSourceConnector extends SourceConnector {
        private String filename;
        private String topic;
</code></pre><p>The easiest method to fill in is <code>taskClass()</code>, which defines the class that should be instantiated in worker processes to actually read the data:</p><pre><code>    @Override
    public Class&lt;? extends Task&gt; taskClass() {
        return FileStreamSourceTask.class;
    }
</code></pre><p>We will define the <code>FileStreamSourceTask</code> class below. Next, we add some standard lifecycle methods, <code>start()</code> and <code>stop()</code>:</p><pre><code>    @Override
    public void start(Map&lt;String, String&gt; props) {
        // The complete version includes error handling as well.
        filename = props.get(FILE_CONFIG);
        topic = props.get(TOPIC_CONFIG);
    }

    @Override
    public void stop() {
        // Nothing to do since no background monitoring is required.
    }
</code></pre><p>Finally, the real core of the implementation is in <code>taskConfigs()</code>. In this case we are only handling a single file, so even though we may be permitted to generate more tasks as per the <code>maxTasks</code> argument, we return a list with only one entry:</p><pre><code>    @Override
    public List&lt;Map&lt;String, String&gt;&gt; taskConfigs(int maxTasks) {
        ArrayList&lt;Map&lt;String, String&gt;&gt; configs = new ArrayList&lt;&gt;();
        // Only one input stream makes sense.
        Map&lt;String, String&gt; config = new HashMap&lt;&gt;();
        if (filename != null)
            config.put(FILE_CONFIG, filename);
        config.put(TOPIC_CONFIG, topic);
        configs.add(config);
        return configs;
    }
</code></pre><p>Although not used in the example, <code>SourceTask</code> also provides two APIs to commit offsets in the source system: <code>commit</code> and <code>commitRecord</code>. The APIs are provided for source systems which have an acknowledgement mechanism for messages. Overriding these methods allows the source connector to acknowledge messages in the source system, either in bulk or individually, once they have been written to Kafka. The <code>commit</code> API stores the offsets in the source system, up to the offsets that have been returned by <code>poll</code>. The implementation of this API should block until the commit is complete. The <code>commitRecord</code> API saves the offset in the source system for each <code>SourceRecord</code> after it is written to Kafka. As Kafka Connect will record offsets automatically, <code>SourceTask</code>s are not required to implement them. In cases where a connector does need to acknowledge messages in the source system, only one of the APIs is typically required.</p><p>Even with multiple tasks, this method implementation is usually pretty simple. It just has to determine the number of input tasks, which may require contacting the remote service it is pulling data from, and then divvy them up. Because some patterns for splitting work among tasks are so common, some utilities are provided in <code>ConnectorUtils</code> to simplify these cases.</p><p>Note that this simple example does not include dynamic input. See the discussion in the next section for how to trigger updates to task configs.</p><h3 id=task-example---source-task>Task Example - Source Task<a class=td-heading-self-link href=#task-example---source-task aria-label="Heading self-link"></a></h3><p>Next we&rsquo;ll describe the implementation of the corresponding <code>SourceTask</code>. The implementation is short, but too long to cover completely in this guide. We&rsquo;ll use pseudo-code to describe most of the implementation, but you can refer to the source code for the full example.</p><p>Just as with the connector, we need to create a class inheriting from the appropriate base <code>Task</code> class. It also has some standard lifecycle methods:</p><pre><code>    public class FileStreamSourceTask extends SourceTask {
        String filename;
        InputStream stream;
        String topic;

        @Override
        public void start(Map&lt;String, String&gt; props) {
            filename = props.get(FileStreamSourceConnector.FILE_CONFIG);
            stream = openOrThrowError(filename);
            topic = props.get(FileStreamSourceConnector.TOPIC_CONFIG);
        }

        @Override
        public synchronized void stop() {
            stream.close();
        }
</code></pre><p>These are slightly simplified versions, but show that these methods should be relatively simple and the only work they should perform is allocating or freeing resources. There are two points to note about this implementation. First, the <code>start()</code> method does not yet handle resuming from a previous offset, which will be addressed in a later section. Second, the <code>stop()</code> method is synchronized. This will be necessary because <code>SourceTasks</code> are given a dedicated thread which they can block indefinitely, so they need to be stopped with a call from a different thread in the Worker.</p><p>Next, we implement the main functionality of the task, the <code>poll()</code> method which gets events from the input system and returns a <code>List&lt;SourceRecord></code>:</p><pre><code>    @Override
    public List&lt;SourceRecord&gt; poll() throws InterruptedException {
        try {
            ArrayList&lt;SourceRecord&gt; records = new ArrayList&lt;&gt;();
            while (streamValid(stream) &amp;&amp; records.isEmpty()) {
                LineAndOffset line = readToNextLine(stream);
                if (line != null) {
                    Map&lt;String, Object&gt; sourcePartition = Collections.singletonMap(&quot;filename&quot;, filename);
                    Map&lt;String, Object&gt; sourceOffset = Collections.singletonMap(&quot;position&quot;, streamOffset);
                    records.add(new SourceRecord(sourcePartition, sourceOffset, topic, Schema.STRING_SCHEMA, line));
                } else {
                    Thread.sleep(1);
                }
            }
            return records;
        } catch (IOException e) {
            // Underlying stream was killed, probably as a result of calling stop. Allow to return
            // null, and driving thread will handle any shutdown if necessary.
        }
        return null;
    }
</code></pre><p>Again, we&rsquo;ve omitted some details, but we can see the important steps: the <code>poll()</code> method is going to be called repeatedly, and for each call it will loop trying to read records from the file. For each line it reads, it also tracks the file offset. It uses this information to create an output <code>SourceRecord</code> with four pieces of information: the source partition (there is only one, the single file being read), source offset (byte offset in the file), output topic name, and output value (the line, and we include a schema indicating this value will always be a string). Other variants of the <code>SourceRecord</code> constructor can also include a specific output partition, a key, and headers.</p><p>Note that this implementation uses the normal Java <code>InputStream</code> interface and may sleep if data is not available. This is acceptable because Kafka Connect provides each task with a dedicated thread. While task implementations have to conform to the basic <code>poll()</code> interface, they have a lot of flexibility in how they are implemented. In this case, an NIO-based implementation would be more efficient, but this simple approach works, is quick to implement, and is compatible with older versions of Java.</p><h3 id=sink-tasks>Sink Tasks<a class=td-heading-self-link href=#sink-tasks aria-label="Heading self-link"></a></h3><p>The previous section described how to implement a simple <code>SourceTask</code>. Unlike <code>SourceConnector</code> and <code>SinkConnector</code>, <code>SourceTask</code> and <code>SinkTask</code> have very different interfaces because <code>SourceTask</code> uses a pull interface and <code>SinkTask</code> uses a push interface. Both share the common lifecycle methods, but the <code>SinkTask</code> interface is quite different:</p><pre><code>    public abstract class SinkTask implements Task {
        public void initialize(SinkTaskContext context) {
            this.context = context;
        }

        public abstract void put(Collection&lt;SinkRecord&gt; records);

        public void flush(Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets) {
        }
</code></pre><p>The <code>SinkTask</code> documentation contains full details, but this interface is nearly as simple as the <code>SourceTask</code>. The <code>put()</code> method should contain most of the implementation, accepting sets of <code>SinkRecords</code>, performing any required translation, and storing them in the destination system. This method does not need to ensure the data has been fully written to the destination system before returning. In fact, in many cases internal buffering will be useful so an entire batch of records can be sent at once, reducing the overhead of inserting events into the downstream data store. The <code>SinkRecords</code> contain essentially the same information as <code>SourceRecords</code>: Kafka topic, partition, offset, the event key and value, and optional headers.</p><p>The <code>flush()</code> method is used during the offset commit process, which allows tasks to recover from failures and resume from a safe point such that no events will be missed. The method should push any outstanding data to the destination system and then block until the write has been acknowledged. The <code>offsets</code> parameter can often be ignored, but is useful in some cases where implementations want to store offset information in the destination store to provide exactly-once delivery. For example, an HDFS connector could do this and use atomic move operations to make sure the <code>flush()</code> operation atomically commits the data and offsets to a final location in HDFS.</p><h3 id=errant-record-reporterconnect_errantrecordreporter><a href=connect_errantrecordreporter>Errant Record Reporter</a><a class=td-heading-self-link href=#errant-record-reporterconnect_errantrecordreporter aria-label="Heading self-link"></a></h3><p>When error reporting is enabled for a connector, the connector can use an <code>ErrantRecordReporter</code> to report problems with individual records sent to a sink connector. The following example shows how a connector&rsquo;s <code>SinkTask</code> subclass might obtain and use the <code>ErrantRecordReporter</code>, safely handling a null reporter when the DLQ is not enabled or when the connector is installed in an older Connect runtime that doesn&rsquo;t have this reporter feature:</p><pre><code>        private ErrantRecordReporter reporter;

        @Override
        public void start(Map&lt;String, String&gt; props) {
            ...
            try {
                reporter = context.errantRecordReporter(); // may be null if DLQ not enabled
            } catch (NoSuchMethodException | NoClassDefFoundError e) {
                // Will occur in Connect runtimes earlier than 2.6
                reporter = null;
            }
        }

        @Override
        public void put(Collection&lt;SinkRecord&gt; records) {
            for (SinkRecord record: records) {
                try {
                    // attempt to process and send record to data sink
                    process(record);
                } catch(Exception e) {
                    if (reporter != null) {
                        // Send errant record to error reporter
                        reporter.report(record, e);
                    } else {
                        // There's no error reporter, so fail
                        throw new ConnectException(&quot;Failed on record&quot;, e);
                    }
                }
            }
        }
</code></pre><h3 id=resuming-from-previous-offsets>Resuming from Previous Offsets<a class=td-heading-self-link href=#resuming-from-previous-offsets aria-label="Heading self-link"></a></h3><p>The <code>SourceTask</code> implementation included a stream ID (the input filename) and offset (position in the file) with each record. The framework uses this to commit offsets periodically so that in the case of a failure, the task can recover and minimize the number of events that are reprocessed and possibly duplicated (or to resume from the most recent offset if Kafka Connect was stopped gracefully, e.g. in standalone mode or due to a job reconfiguration). This commit process is completely automated by the framework, but only the connector knows how to seek back to the right position in the input stream to resume from that location.</p><p>To correctly resume upon startup, the task can use the <code>SourceContext</code> passed into its <code>initialize()</code> method to access the offset data. In <code>initialize()</code>, we would add a bit more code to read the offset (if it exists) and seek to that position:</p><pre><code>        stream = new FileInputStream(filename);
        Map&lt;String, Object&gt; offset = context.offsetStorageReader().offset(Collections.singletonMap(FILENAME_FIELD, filename));
        if (offset != null) {
            Long lastRecordedOffset = (Long) offset.get(&quot;position&quot;);
            if (lastRecordedOffset != null)
                seekToOffset(stream, lastRecordedOffset);
        }
</code></pre><p>Of course, you might need to read many keys for each of the input streams. The <code>OffsetStorageReader</code> interface also allows you to issue bulk reads to efficiently load all offsets, then apply them by seeking each input stream to the appropriate position.</p><h2 id=dynamic-inputoutput-streams>Dynamic Input/Output Streams<a class=td-heading-self-link href=#dynamic-inputoutput-streams aria-label="Heading self-link"></a></h2><p>Kafka Connect is intended to define bulk data copying jobs, such as copying an entire database rather than creating many jobs to copy each table individually. One consequence of this design is that the set of input or output streams for a connector can vary over time.</p><p>Source connectors need to monitor the source system for changes, e.g. table additions/deletions in a database. When they pick up changes, they should notify the framework via the <code>ConnectorContext</code> object that reconfiguration is necessary. For example, in a <code>SourceConnector</code>:</p><pre><code>        if (inputsChanged())
            this.context.requestTaskReconfiguration();
</code></pre><p>The framework will promptly request new configuration information and update the tasks, allowing them to gracefully commit their progress before reconfiguring them. Note that in the <code>SourceConnector</code> this monitoring is currently left up to the connector implementation. If an extra thread is required to perform this monitoring, the connector must allocate it itself.</p><p>Ideally this code for monitoring changes would be isolated to the <code>Connector</code> and tasks would not need to worry about them. However, changes can also affect tasks, most commonly when one of their input streams is destroyed in the input system, e.g. if a table is dropped from a database. If the <code>Task</code> encounters the issue before the <code>Connector</code>, which will be common if the <code>Connector</code> needs to poll for changes, the <code>Task</code> will need to handle the subsequent error. Thankfully, this can usually be handled simply by catching and handling the appropriate exception.</p><p><code>SinkConnectors</code> usually only have to handle the addition of streams, which may translate to new entries in their outputs (e.g., a new database table). The framework manages any changes to the Kafka input, such as when the set of input topics changes because of a regex subscription. <code>SinkTasks</code> should expect new input streams, which may require creating new resources in the downstream system, such as a new table in a database. The trickiest situation to handle in these cases may be conflicts between multiple <code>SinkTasks</code> seeing a new input stream for the first time and simultaneously trying to create the new resource. <code>SinkConnectors</code>, on the other hand, will generally require no special code for handling a dynamic set of streams.</p><h2 id=connect-configuration-validation>Connect Configuration Validation<a class=td-heading-self-link href=#connect-configuration-validation aria-label="Heading self-link"></a></h2><p>Kafka Connect allows you to validate connector configurations before submitting a connector to be executed and can provide feedback about errors and recommended values. To take advantage of this, connector developers need to provide an implementation of <code>config()</code> to expose the configuration definition to the framework.</p><p>The following code in <code>FileStreamSourceConnector</code> defines the configuration and exposes it to the framework.</p><pre><code>        private static final ConfigDef CONFIG_DEF = new ConfigDef()
            .define(FILE_CONFIG, Type.STRING, Importance.HIGH, &quot;Source filename.&quot;)
            .define(TOPIC_CONFIG, Type.STRING, Importance.HIGH, &quot;The topic to publish data to&quot;);

        public ConfigDef config() {
            return CONFIG_DEF;
        }
</code></pre><p><code>ConfigDef</code> class is used for specifying the set of expected configurations. For each configuration, you can specify the name, the type, the default value, the documentation, the group information, the order in the group, the width of the configuration value and the name suitable for display in the UI. Plus, you can provide special validation logic used for single configuration validation by overriding the <code>Validator</code> class. Moreover, as there may be dependencies between configurations, for example, the valid values and visibility of a configuration may change according to the values of other configurations. To handle this, <code>ConfigDef</code> allows you to specify the dependents of a configuration and to provide an implementation of <code>Recommender</code> to get valid values and set visibility of a configuration given the current configuration values.</p><p>Also, the <code>validate()</code> method in <code>Connector</code> provides a default validation implementation which returns a list of allowed configurations together with configuration errors and recommended values for each configuration. However, it does not use the recommended values for configuration validation. You may provide an override of the default implementation for customized configuration validation, which may use the recommended values.</p><h2 id=working-with-schemas>Working with Schemas<a class=td-heading-self-link href=#working-with-schemas aria-label="Heading self-link"></a></h2><p>The FileStream connectors are good examples because they are simple, but they also have trivially structured data &ndash; each line is just a string. Almost all practical connectors will need schemas with more complex data formats.</p><p>To create more complex data, you&rsquo;ll need to work with the Kafka Connect <code>data</code> API. Most structured records will need to interact with two classes in addition to primitive types: <code>Schema</code> and <code>Struct</code>.</p><p>The API documentation provides a complete reference, but here is a simple example creating a <code>Schema</code> and <code>Struct</code>:</p><pre><code>    Schema schema = SchemaBuilder.struct().name(NAME)
        .field(&quot;name&quot;, Schema.STRING_SCHEMA)
        .field(&quot;age&quot;, Schema.INT_SCHEMA)
        .field(&quot;admin&quot;, SchemaBuilder.bool().defaultValue(false).build())
        .build();

    Struct struct = new Struct(schema)
        .put(&quot;name&quot;, &quot;Barbara Liskov&quot;)
        .put(&quot;age&quot;, 75);
</code></pre><p>If you are implementing a source connector, you&rsquo;ll need to decide when and how to create schemas. Where possible, you should avoid recomputing them as much as possible. For example, if your connector is guaranteed to have a fixed schema, create it statically and reuse a single instance.</p><p>However, many connectors will have dynamic schemas. One simple example of this is a database connector. Considering even just a single table, the schema will not be predefined for the entire connector (as it varies from table to table). But it also may not be fixed for a single table over the lifetime of the connector since the user may execute an <code>ALTER TABLE</code> command. The connector must be able to detect these changes and react appropriately.</p><p>Sink connectors are usually simpler because they are consuming data and therefore do not need to create schemas. However, they should take just as much care to validate that the schemas they receive have the expected format. When the schema does not match &ndash; usually indicating the upstream producer is generating invalid data that cannot be correctly translated to the destination system &ndash; sink connectors should throw an exception to indicate this error to the system.</p><h2 id=kafka-connect-administration>Kafka Connect Administration<a class=td-heading-self-link href=#kafka-connect-administration aria-label="Heading self-link"></a></h2><p>Kafka Connect&rsquo;s REST layer provides a set of APIs to enable administration of the cluster. This includes APIs to view the configuration of connectors and the status of their tasks, as well as to alter their current behavior (e.g. changing configuration and restarting tasks).</p><p>When a connector is first submitted to the cluster, a rebalance is triggered between the Connect workers in order to distribute the load that consists of the tasks of the new connector. This same rebalancing procedure is also used when connectors increase or decrease the number of tasks they require, when a connector&rsquo;s configuration is changed, or when a worker is added or removed from the group as part of an intentional upgrade of the Connect cluster or due to a failure.</p><p>In versions prior to 2.3.0, the Connect workers would rebalance the full set of connectors and their tasks in the cluster as a simple way to make sure that each worker has approximately the same amount of work. This behavior can be still enabled by setting <code>connect.protocol=eager</code>.</p><p>Starting with 2.3.0, Kafka Connect is using by default a protocol that performs <a href=https://cwiki.apache.org/confluence/display/KAFKA/KIP-415%3A+Incremental+Cooperative+Rebalancing+in+Kafka+Connect>incremental cooperative rebalancing</a> that incrementally balances the connectors and tasks across the Connect workers, affecting only tasks that are new, to be removed, or need to move from one worker to another. Other tasks are not stopped and restarted during the rebalance, as they would have been with the old protocol.</p><p>If a Connect worker leaves the group, intentionally or due to a failure, Connect waits for <code>scheduled.rebalance.max.delay.ms</code> before triggering a rebalance. This delay defaults to five minutes (<code>300000ms</code>) to tolerate failures or upgrades of workers without immediately redistributing the load of a departing worker. If this worker returns within the configured delay, it gets its previously assigned tasks in full. However, this means that the tasks will remain unassigned until the time specified by <code>scheduled.rebalance.max.delay.ms</code> elapses. If a worker does not return within that time limit, Connect will reassign those tasks among the remaining workers in the Connect cluster.</p><p>The new Connect protocol is enabled when all the workers that form the Connect cluster are configured with <code>connect.protocol=compatible</code>, which is also the default value when this property is missing. Therefore, upgrading to the new Connect protocol happens automatically when all the workers upgrade to 2.3.0. A rolling upgrade of the Connect cluster will activate incremental cooperative rebalancing when the last worker joins on version 2.3.0.</p><p>You can use the REST API to view the current status of a connector and its tasks, including the ID of the worker to which each was assigned. For example, the <code>GET /connectors/file-source/status</code> request shows the status of a connector named <code>file-source</code>:</p><pre><code>    {
    &quot;name&quot;: &quot;file-source&quot;,
    &quot;connector&quot;: {
        &quot;state&quot;: &quot;RUNNING&quot;,
        &quot;worker_id&quot;: &quot;192.168.1.208:8083&quot;
    },
    &quot;tasks&quot;: [
        {
        &quot;id&quot;: 0,
        &quot;state&quot;: &quot;RUNNING&quot;,
        &quot;worker_id&quot;: &quot;192.168.1.209:8083&quot;
        }
    ]
    }
</code></pre><p>Connectors and their tasks publish status updates to a shared topic (configured with <code>status.storage.topic</code>) which all workers in the cluster monitor. Because the workers consume this topic asynchronously, there is typically a (short) delay before a state change is visible through the status API. The following states are possible for a connector or one of its tasks:</p><ul><li><strong>UNASSIGNED:</strong> The connector/task has not yet been assigned to a worker.</li><li><strong>RUNNING:</strong> The connector/task is running.</li><li><strong>PAUSED:</strong> The connector/task has been administratively paused.</li><li><strong>FAILED:</strong> The connector/task has failed (usually by raising an exception, which is reported in the status output).</li><li><strong>DESTROYED:</strong> The connector/task has been administratively removed and will stop appearing in the Connect cluster.</li></ul><p>In most cases, connector and task states will match, though they may be different for short periods of time when changes are occurring or if tasks have failed. For example, when a connector is first started, there may be a noticeable delay before the connector and its tasks have all transitioned to the RUNNING state. States will also diverge when tasks fail since Connect does not automatically restart failed tasks. To restart a connector/task manually, you can use the restart APIs listed above. Note that if you try to restart a task while a rebalance is taking place, Connect will return a 409 (Conflict) status code. You can retry after the rebalance completes, but it might not be necessary since rebalances effectively restart all the connectors and tasks in the cluster.</p><p>Starting with 2.5.0, Kafka Connect uses the <code>status.storage.topic</code> to also store information related to the topics that each connector is using. Connect Workers use these per-connector topic status updates to respond to requests to the REST endpoint <code>GET /connectors/{name}/topics</code> by returning the set of topic names that a connector is using. A request to the REST endpoint <code>PUT /connectors/{name}/topics/reset</code> resets the set of active topics for a connector and allows a new set to be populated, based on the connector&rsquo;s latest pattern of topic usage. Upon connector deletion, the set of the connector&rsquo;s active topics is also deleted. Topic tracking is enabled by default but can be disabled by setting <code>topic.tracking.enable=false</code>. If you want to disallow requests to reset the active topics of connectors during runtime, set the Worker property <code>topic.tracking.allow.reset=false</code>.</p><p>It&rsquo;s sometimes useful to temporarily stop the message processing of a connector. For example, if the remote system is undergoing maintenance, it would be preferable for source connectors to stop polling it for new data instead of filling logs with exception spam. For this use case, Connect offers a pause/resume API. While a source connector is paused, Connect will stop polling it for additional records. While a sink connector is paused, Connect will stop pushing new messages to it. The pause state is persistent, so even if you restart the cluster, the connector will not begin message processing again until the task has been resumed. Note that there may be a delay before all of a connector&rsquo;s tasks have transitioned to the PAUSED state since it may take time for them to finish whatever processing they were in the middle of when being paused. Additionally, failed tasks will not transition to the PAUSED state until they have been restarted.</p></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=Contact aria-label=Contact><a target=_blank rel=noopener href=/community/contact/ aria-label=Contact><i class="fa fa-envelope"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Twitter aria-label=Twitter><a target=_blank rel=noopener href=https://twitter.com/apachekafka aria-label=Twitter><i class="fab fa-twitter"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Stack Overflow" aria-label="Stack Overflow"><a target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/apache-kafka aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/apache/kafka aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Developer mailing list" aria-label="Developer mailing list"><a target=_blank rel=noopener href=mailto:dev@kafka.apache.org aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2014&ndash;2025
<span class=td-footer__authors>By <a href=https://www.apache.org/>Apache Software Foundation</a> under the terms of the <a href=https://www.apache.org/licenses/LICENSE-2.0>Apache License v2</a></span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span><span class=ms-2><a href=https://privacy.apache.org/policies/privacy-policy-public.html target=_blank rel=noopener>Privacy Policy</a></span></div></div></div></footer></div><script src=/js/main.min.dc2c0119076a0df855e55a8044ce0de74b7b9033c20e853e22d7ec7e9bdde965.js integrity="sha256-3CwBGQdqDfhV5VqARM4N50t7kDPCDoU+Itfsfpvd6WU=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>
<ul class="config-list">
<li>
<h4><a id="node.id"></a><a id="brokerconfigs_node.id" href="#brokerconfigs_node.id">node.id</a></h4>
<p>The node ID associated with the roles this process is playing when <code>process.roles</code> is non-empty. This is required configuration when running in KRaft mode.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td></td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="process.roles"></a><a id="brokerconfigs_process.roles" href="#brokerconfigs_process.roles">process.roles</a></h4>
<p>The roles that this process plays: 'broker', 'controller', or 'broker,controller' if it is both. </p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td></td></tr>
<tr><th>Valid Values:</th><td>[broker, controller]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="add.partitions.to.txn.retry.backoff.max.ms"></a><a id="brokerconfigs_add.partitions.to.txn.retry.backoff.max.ms" href="#brokerconfigs_add.partitions.to.txn.retry.backoff.max.ms">add.partitions.to.txn.retry.backoff.max.ms</a></h4>
<p>The maximum allowed timeout for adding partitions to transactions on the server side. It only applies to the actual add partition operations, not the verification. It will not be effective if it is larger than request.timeout.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>100</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="add.partitions.to.txn.retry.backoff.ms"></a><a id="brokerconfigs_add.partitions.to.txn.retry.backoff.ms" href="#brokerconfigs_add.partitions.to.txn.retry.backoff.ms">add.partitions.to.txn.retry.backoff.ms</a></h4>
<p>The server-side retry backoff when the server attemptsto add the partition to the transaction</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>20</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="advertised.listeners"></a><a id="brokerconfigs_advertised.listeners" href="#brokerconfigs_advertised.listeners">advertised.listeners</a></h4>
<p>Specifies the listener addresses that the Kafka brokers will advertise to clients and other brokers. The config is useful where the actual listener configuration <code>listeners</code> does not represent the addresses that clients should use to connect, such as in cloud environments. The addresses are published to and managed by the controller, the brokers pull these data from the controller as needed. In IaaS environments, this may need to be different from the interface to which the broker binds. If this is not set, the value for <code>listeners</code> will be used. Unlike <code>listeners</code>, it is not valid to advertise the 0.0.0.0 meta-address.<br> Also unlike <code>listeners</code>, there can be duplicated ports in this property, so that one listener can be configured to advertise another listener's address. This can be useful in some cases where external load balancers are used.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="auto.create.topics.enable"></a><a id="brokerconfigs_auto.create.topics.enable" href="#brokerconfigs_auto.create.topics.enable">auto.create.topics.enable</a></h4>
<p>Enable auto creation of topic on the server.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="auto.leader.rebalance.enable"></a><a id="brokerconfigs_auto.leader.rebalance.enable" href="#brokerconfigs_auto.leader.rebalance.enable">auto.leader.rebalance.enable</a></h4>
<p>Enables auto leader balancing. A background thread checks the distribution of partition leaders at regular intervals, configurable by leader.imbalance.check.interval.seconds. If the leader is imbalanced, leader rebalance to the preferred leader for partitions is triggered.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="background.threads"></a><a id="brokerconfigs_background.threads" href="#brokerconfigs_background.threads">background.threads</a></h4>
<p>The number of threads to use for various background processing tasks</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="broker.id"></a><a id="brokerconfigs_broker.id" href="#brokerconfigs_broker.id">broker.id</a></h4>
<p>The broker id for this server.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>-1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="compression.type"></a><a id="brokerconfigs_compression.type" href="#brokerconfigs_compression.type">compression.type</a></h4>
<p>Specify the final compression type for a given topic. This configuration accepts the standard compression codecs ('gzip', 'snappy', 'lz4', 'zstd'). It additionally accepts 'uncompressed' which is equivalent to no compression; and 'producer' which means retain the original compression codec set by the producer.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>producer</td></tr>
<tr><th>Valid Values:</th><td>[uncompressed, zstd, lz4, snappy, gzip, producer]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.listener.names"></a><a id="brokerconfigs_controller.listener.names" href="#brokerconfigs_controller.listener.names">controller.listener.names</a></h4>
<p>A comma-separated list of the names of the listeners used by the controller. This is required when communicating with the controller quorum, the broker will always use the first listener in this list.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.bootstrap.servers"></a><a id="brokerconfigs_controller.quorum.bootstrap.servers" href="#brokerconfigs_controller.quorum.bootstrap.servers">controller.quorum.bootstrap.servers</a></h4>
<p>List of endpoints to use for bootstrapping the cluster metadata. The endpoints are specified in comma-separated list of <code>{host}:{port}</code> entries. For example: <code>localhost:9092,localhost:9093,localhost:9094</code>.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td>non-empty list</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.election.backoff.max.ms"></a><a id="brokerconfigs_controller.quorum.election.backoff.max.ms" href="#brokerconfigs_controller.quorum.election.backoff.max.ms">controller.quorum.election.backoff.max.ms</a></h4>
<p>Maximum time in milliseconds before starting new elections. This is used in the binary exponential backoff mechanism that helps prevent gridlocked elections</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000 (1 second)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.election.timeout.ms"></a><a id="brokerconfigs_controller.quorum.election.timeout.ms" href="#brokerconfigs_controller.quorum.election.timeout.ms">controller.quorum.election.timeout.ms</a></h4>
<p>Maximum time in milliseconds to wait without being able to fetch from the leader before triggering a new election</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000 (1 second)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.fetch.timeout.ms"></a><a id="brokerconfigs_controller.quorum.fetch.timeout.ms" href="#brokerconfigs_controller.quorum.fetch.timeout.ms">controller.quorum.fetch.timeout.ms</a></h4>
<p>Maximum time without a successful fetch from the current leader before becoming a candidate and triggering an election for voters; Maximum time a leader can go without receiving valid fetch or fetchSnapshot request from a majority of the quorum before resigning.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000 (2 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.voters"></a><a id="brokerconfigs_controller.quorum.voters" href="#brokerconfigs_controller.quorum.voters">controller.quorum.voters</a></h4>
<p>Map of id/endpoint information for the set of voters in a comma-separated list of <code>{id}@{host}:{port}</code> entries. For example: <code>1@localhost:9092,2@localhost:9093,3@localhost:9094</code></p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td>non-empty list</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delete.topic.enable"></a><a id="brokerconfigs_delete.topic.enable" href="#brokerconfigs_delete.topic.enable">delete.topic.enable</a></h4>
<p>When set to true, topics can be deleted by the admin client. When set to false, deletion requests will be explicitly rejected by the broker.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="early.start.listeners"></a><a id="brokerconfigs_early.start.listeners" href="#brokerconfigs_early.start.listeners">early.start.listeners</a></h4>
<p>A comma-separated list of listener names which may be started before the authorizer has finished initialization. This is useful when the authorizer is dependent on the cluster itself for bootstrapping, as is the case for the StandardAuthorizer (which stores ACLs in the metadata log.) By default, all listeners included in controller.listener.names will also be early start listeners. A listener should not appear in this list if it accepts external traffic.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.coordinator.threads"></a><a id="brokerconfigs_group.coordinator.threads" href="#brokerconfigs_group.coordinator.threads">group.coordinator.threads</a></h4>
<p>The number of threads used by the group coordinator.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>4</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="leader.imbalance.check.interval.seconds"></a><a id="brokerconfigs_leader.imbalance.check.interval.seconds" href="#brokerconfigs_leader.imbalance.check.interval.seconds">leader.imbalance.check.interval.seconds</a></h4>
<p>The frequency with which the partition rebalance check is triggered by the controller</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>300</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="listeners"></a><a id="brokerconfigs_listeners" href="#brokerconfigs_listeners">listeners</a></h4>
<p>Listener List - Comma-separated list of URIs we will listen on and the listener names. If the listener name is not a security protocol, <code>listener.security.protocol.map</code> must also be set.<br> Listener names and port numbers must be unique unless one listener is an IPv4 address and the other listener is an IPv6 address (for the same port).<br> Specify hostname as 0.0.0.0 to bind to all interfaces.<br> Leave hostname empty to bind to default interface.<br> Examples of legal listener lists:<br> <code>PLAINTEXT://myhost:9092,SSL://:9091</code><br> <code>CLIENT://0.0.0.0:9092,REPLICATION://localhost:9093</code><br> <code>PLAINTEXT://127.0.0.1:9092,SSL://[::1]:9092</code><br></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>PLAINTEXT://:9092</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.dir"></a><a id="brokerconfigs_log.dir" href="#brokerconfigs_log.dir">log.dir</a></h4>
<p>The directory in which the log data is kept (supplemental for log.dirs property)</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>/tmp/kafka-logs</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.dirs"></a><a id="brokerconfigs_log.dirs" href="#brokerconfigs_log.dirs">log.dirs</a></h4>
<p>A comma-separated list of the directories where the log data is stored. If not set, the value in log.dir is used.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.flush.interval.messages"></a><a id="brokerconfigs_log.flush.interval.messages" href="#brokerconfigs_log.flush.interval.messages">log.flush.interval.messages</a></h4>
<p>The number of messages accumulated on a log partition before messages are flushed to disk.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.flush.interval.ms"></a><a id="brokerconfigs_log.flush.interval.ms" href="#brokerconfigs_log.flush.interval.ms">log.flush.interval.ms</a></h4>
<p>The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.flush.offset.checkpoint.interval.ms"></a><a id="brokerconfigs_log.flush.offset.checkpoint.interval.ms" href="#brokerconfigs_log.flush.offset.checkpoint.interval.ms">log.flush.offset.checkpoint.interval.ms</a></h4>
<p>The frequency with which we update the persistent record of the last flush which acts as the log recovery point.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.flush.scheduler.interval.ms"></a><a id="brokerconfigs_log.flush.scheduler.interval.ms" href="#brokerconfigs_log.flush.scheduler.interval.ms">log.flush.scheduler.interval.ms</a></h4>
<p>The frequency in ms that the log flusher checks whether any log needs to be flushed to disk</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.flush.start.offset.checkpoint.interval.ms"></a><a id="brokerconfigs_log.flush.start.offset.checkpoint.interval.ms" href="#brokerconfigs_log.flush.start.offset.checkpoint.interval.ms">log.flush.start.offset.checkpoint.interval.ms</a></h4>
<p>The frequency with which we update the persistent record of log start offset</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.retention.bytes"></a><a id="brokerconfigs_log.retention.bytes" href="#brokerconfigs_log.retention.bytes">log.retention.bytes</a></h4>
<p>The maximum size of the log before deleting it</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>-1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.retention.hours"></a><a id="brokerconfigs_log.retention.hours" href="#brokerconfigs_log.retention.hours">log.retention.hours</a></h4>
<p>The number of hours to keep a log file before deleting it (in hours), tertiary to log.retention.ms property</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>168</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.retention.minutes"></a><a id="brokerconfigs_log.retention.minutes" href="#brokerconfigs_log.retention.minutes">log.retention.minutes</a></h4>
<p>The number of minutes to keep a log file before deleting it (in minutes), secondary to log.retention.ms property. If not set, the value in log.retention.hours is used</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.retention.ms"></a><a id="brokerconfigs_log.retention.ms" href="#brokerconfigs_log.retention.ms">log.retention.ms</a></h4>
<p>The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.roll.hours"></a><a id="brokerconfigs_log.roll.hours" href="#brokerconfigs_log.roll.hours">log.roll.hours</a></h4>
<p>The maximum time before a new log segment is rolled out (in hours), secondary to log.roll.ms property</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>168</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.roll.jitter.hours"></a><a id="brokerconfigs_log.roll.jitter.hours" href="#brokerconfigs_log.roll.jitter.hours">log.roll.jitter.hours</a></h4>
<p>The maximum jitter to subtract from logRollTimeMillis (in hours), secondary to log.roll.jitter.ms property</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.roll.jitter.ms"></a><a id="brokerconfigs_log.roll.jitter.ms" href="#brokerconfigs_log.roll.jitter.ms">log.roll.jitter.ms</a></h4>
<p>The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.roll.ms"></a><a id="brokerconfigs_log.roll.ms" href="#brokerconfigs_log.roll.ms">log.roll.ms</a></h4>
<p>The maximum time before a new log segment is rolled out (in milliseconds). If not set, the value in log.roll.hours is used</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.segment.bytes"></a><a id="brokerconfigs_log.segment.bytes" href="#brokerconfigs_log.segment.bytes">log.segment.bytes</a></h4>
<p>The maximum size of a single log file</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1073741824 (1 gibibyte)</td></tr>
<tr><th>Valid Values:</th><td>[1048576,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.segment.delete.delay.ms"></a><a id="brokerconfigs_log.segment.delete.delay.ms" href="#brokerconfigs_log.segment.delete.delay.ms">log.segment.delete.delay.ms</a></h4>
<p>The amount of time to wait before deleting a file from the filesystem. If the value is 0 and there is no file to delete, the system will wait 1 millisecond. Low value will cause busy waiting</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="message.max.bytes"></a><a id="brokerconfigs_message.max.bytes" href="#brokerconfigs_message.max.bytes">message.max.bytes</a></h4>
<p>The largest record batch size allowed by Kafka (after compression if compression is enabled).This can be set per topic with the topic level <code>max.message.bytes</code> config.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1048588</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.log.dir"></a><a id="brokerconfigs_metadata.log.dir" href="#brokerconfigs_metadata.log.dir">metadata.log.dir</a></h4>
<p>This configuration determines where we put the metadata log. If it is not set, the metadata log is placed in the first log directory from log.dirs.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.log.max.record.bytes.between.snapshots"></a><a id="brokerconfigs_metadata.log.max.record.bytes.between.snapshots" href="#brokerconfigs_metadata.log.max.record.bytes.between.snapshots">metadata.log.max.record.bytes.between.snapshots</a></h4>
<p>This is the maximum number of bytes in the log between the latest snapshot and the high-watermark needed before generating a new snapshot. The default value is 20971520. To generate snapshots based on the time elapsed, see the <code>metadata.log.max.snapshot.interval.ms</code> configuration. The Kafka node will generate a snapshot when either the maximum time interval is reached or the maximum bytes limit is reached.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>20971520</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.log.max.snapshot.interval.ms"></a><a id="brokerconfigs_metadata.log.max.snapshot.interval.ms" href="#brokerconfigs_metadata.log.max.snapshot.interval.ms">metadata.log.max.snapshot.interval.ms</a></h4>
<p>This is the maximum number of milliseconds to wait to generate a snapshot if there are committed records in the log that are not included in the latest snapshot. A value of zero disables time based snapshot generation. The default value is 3600000. To generate snapshots based on the number of metadata bytes, see the <code>metadata.log.max.record.bytes.between.snapshots</code> configuration. The Kafka node will generate a snapshot when either the maximum time interval is reached or the maximum bytes limit is reached.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>3600000 (1 hour)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.log.segment.bytes"></a><a id="brokerconfigs_metadata.log.segment.bytes" href="#brokerconfigs_metadata.log.segment.bytes">metadata.log.segment.bytes</a></h4>
<p>The maximum size of a single metadata log file.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1073741824 (1 gibibyte)</td></tr>
<tr><th>Valid Values:</th><td>[8388608,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.log.segment.ms"></a><a id="brokerconfigs_metadata.log.segment.ms" href="#brokerconfigs_metadata.log.segment.ms">metadata.log.segment.ms</a></h4>
<p>The maximum time before a new metadata log file is rolled out (in milliseconds).</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>604800000 (7 days)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.max.retention.bytes"></a><a id="brokerconfigs_metadata.max.retention.bytes" href="#brokerconfigs_metadata.max.retention.bytes">metadata.max.retention.bytes</a></h4>
<p>The maximum combined size of the metadata log and snapshots before deleting old snapshots and log files. Since at least one snapshot must exist before any logs can be deleted, this is a soft limit.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>104857600 (100 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.max.retention.ms"></a><a id="brokerconfigs_metadata.max.retention.ms" href="#brokerconfigs_metadata.max.retention.ms">metadata.max.retention.ms</a></h4>
<p>The number of milliseconds to keep a metadata log file or snapshot before deleting it. Since at least one snapshot must exist before any logs can be deleted, this is a soft limit.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>604800000 (7 days)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="min.insync.replicas"></a><a id="brokerconfigs_min.insync.replicas" href="#brokerconfigs_min.insync.replicas">min.insync.replicas</a></h4>
<p>Specifies the <i>minimum</i> number of in-sync replicas (including the leader) required for a write to succeed when a producer sets <code>acks</code> to "all" (or "-1"). In the <code>acks=all</code> case, every in-sync replica must acknowledge a write for it to be considered successful. E.g., if a topic has <code>replication.factor</code> of 3 and the ISR set includes all three replicas, then all three replicas must acknowledge an <code>acks=all</code> write for it to succeed, even if <code>min.insync.replicas</code> happens to be less than 3. If <code>acks=all</code> and the current ISR set contains fewer than <code>min.insync.replicas</code> members, then the producer will raise an exception (either <code>NotEnoughReplicas</code> or <code>NotEnoughReplicasAfterAppend</code>).<br> Regardless of the <code>acks</code> setting, the messages will not be visible to the consumers until they are replicated to all in-sync replicas and the <code>min.insync.replicas</code> condition is met.<br> When used together, <code>min.insync.replicas</code> and <code>acks</code> allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set <code>min.insync.replicas</code> to 2, and produce with <code>acks</code> of "all". This ensures that a majority of replicas must persist a write before it's considered successful by the producer and it's visible to consumers.<p>Note that when the Eligible Leader Replicas feature is enabled, the semantics of this config changes. Please refer to <a href="#eligible_leader_replicas">the ELR section</a> for more info.</p></p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.io.threads"></a><a id="brokerconfigs_num.io.threads" href="#brokerconfigs_num.io.threads">num.io.threads</a></h4>
<p>The number of threads that the server uses for processing requests, which may include disk I/O</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>8</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.network.threads"></a><a id="brokerconfigs_num.network.threads" href="#brokerconfigs_num.network.threads">num.network.threads</a></h4>
<p>The number of threads that the server uses for receiving requests from the network and sending responses to the network. Noted: each listener (except for controller listener) creates its own thread pool.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>3</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.recovery.threads.per.data.dir"></a><a id="brokerconfigs_num.recovery.threads.per.data.dir" href="#brokerconfigs_num.recovery.threads.per.data.dir">num.recovery.threads.per.data.dir</a></h4>
<p>The number of threads per data directory to be used for log recovery at startup and flushing at shutdown</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.replica.alter.log.dirs.threads"></a><a id="brokerconfigs_num.replica.alter.log.dirs.threads" href="#brokerconfigs_num.replica.alter.log.dirs.threads">num.replica.alter.log.dirs.threads</a></h4>
<p>The number of threads that can move replicas between log directories, which may include disk I/O. The default value is equal to the number of directories specified in the <code>log.dir</code> or <code>log.dirs</code> configuration property.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.replica.fetchers"></a><a id="brokerconfigs_num.replica.fetchers" href="#brokerconfigs_num.replica.fetchers">num.replica.fetchers</a></h4>
<p>Number of fetcher threads used to replicate records from each source broker. The total number of fetchers on each broker is bound by <code>num.replica.fetchers</code> multiplied by the number of brokers in the cluster.Increasing this value can increase the degree of I/O parallelism in the follower and leader broker at the cost of higher CPU and memory utilization.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offset.metadata.max.bytes"></a><a id="brokerconfigs_offset.metadata.max.bytes" href="#brokerconfigs_offset.metadata.max.bytes">offset.metadata.max.bytes</a></h4>
<p>The maximum size for a metadata entry associated with an offset commit.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>4096 (4 kibibytes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.commit.timeout.ms"></a><a id="brokerconfigs_offsets.commit.timeout.ms" href="#brokerconfigs_offsets.commit.timeout.ms">offsets.commit.timeout.ms</a></h4>
<p>Offset commit will be delayed until all replicas for the offsets topic receive the commit or this timeout is reached. This is similar to the producer request timeout. This is applied to all the writes made by the coordinator.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.load.buffer.size"></a><a id="brokerconfigs_offsets.load.buffer.size" href="#brokerconfigs_offsets.load.buffer.size">offsets.load.buffer.size</a></h4>
<p>Batch size for reading from the offsets segments when loading group metadata  into the cache (soft-limit, overridden if records are too large).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5242880</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.retention.check.interval.ms"></a><a id="brokerconfigs_offsets.retention.check.interval.ms" href="#brokerconfigs_offsets.retention.check.interval.ms">offsets.retention.check.interval.ms</a></h4>
<p>Frequency at which to check for stale offsets</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>600000 (10 minutes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.retention.minutes"></a><a id="brokerconfigs_offsets.retention.minutes" href="#brokerconfigs_offsets.retention.minutes">offsets.retention.minutes</a></h4>
<p>For subscribed consumers, committed offset of a specific partition will be expired and discarded when 1) this retention period has elapsed after the consumer group loses all its consumers (i.e. becomes empty); 2) this retention period has elapsed since the last time an offset is committed for the partition and the group is no longer subscribed to the corresponding topic. For standalone consumers (using manual assignment), offsets will be expired after this retention period has elapsed since the time of last commit. Note that when a group is deleted via the delete-group request, its committed offsets will also be deleted without extra retention period; also when a topic is deleted via the delete-topic request, upon propagated metadata update any group's committed offsets for that topic will also be deleted without extra retention period.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10080</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.topic.compression.codec"></a><a id="brokerconfigs_offsets.topic.compression.codec" href="#brokerconfigs_offsets.topic.compression.codec">offsets.topic.compression.codec</a></h4>
<p>Compression codec for the offsets topic - compression may be used to achieve "atomic" commits.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.topic.num.partitions"></a><a id="brokerconfigs_offsets.topic.num.partitions" href="#brokerconfigs_offsets.topic.num.partitions">offsets.topic.num.partitions</a></h4>
<p>The number of partitions for the offset commit topic (should not change after deployment).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>50</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.topic.replication.factor"></a><a id="brokerconfigs_offsets.topic.replication.factor" href="#brokerconfigs_offsets.topic.replication.factor">offsets.topic.replication.factor</a></h4>
<p>The replication factor for the offsets topic (set higher to ensure availability). Internal topic creation will fail until the cluster size meets this replication factor requirement.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>3</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="offsets.topic.segment.bytes"></a><a id="brokerconfigs_offsets.topic.segment.bytes" href="#brokerconfigs_offsets.topic.segment.bytes">offsets.topic.segment.bytes</a></h4>
<p>The offsets topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>104857600 (100 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="queued.max.requests"></a><a id="brokerconfigs_queued.max.requests" href="#brokerconfigs_queued.max.requests">queued.max.requests</a></h4>
<p>The number of queued requests allowed for data-plane, before blocking the network threads</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>500</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.fetch.min.bytes"></a><a id="brokerconfigs_replica.fetch.min.bytes" href="#brokerconfigs_replica.fetch.min.bytes">replica.fetch.min.bytes</a></h4>
<p>Minimum bytes expected for each fetch response. If not enough bytes, wait up to <code>replica.fetch.wait.max.ms</code> (broker config).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.fetch.wait.max.ms"></a><a id="brokerconfigs_replica.fetch.wait.max.ms" href="#brokerconfigs_replica.fetch.wait.max.ms">replica.fetch.wait.max.ms</a></h4>
<p>The maximum wait time for each fetcher request issued by follower replicas. This value should always be less than the replica.lag.time.max.ms at all times to prevent frequent shrinking of ISR for low throughput topics</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>500</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.high.watermark.checkpoint.interval.ms"></a><a id="brokerconfigs_replica.high.watermark.checkpoint.interval.ms" href="#brokerconfigs_replica.high.watermark.checkpoint.interval.ms">replica.high.watermark.checkpoint.interval.ms</a></h4>
<p>The frequency with which the high watermark is saved out to disk</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.lag.time.max.ms"></a><a id="brokerconfigs_replica.lag.time.max.ms" href="#brokerconfigs_replica.lag.time.max.ms">replica.lag.time.max.ms</a></h4>
<p>If a follower hasn't sent any fetch requests or hasn't consumed up to the leader's log end offset for at least this time, the leader will remove the follower from ISR</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.socket.receive.buffer.bytes"></a><a id="brokerconfigs_replica.socket.receive.buffer.bytes" href="#brokerconfigs_replica.socket.receive.buffer.bytes">replica.socket.receive.buffer.bytes</a></h4>
<p>The socket receive buffer for network requests to the leader for replicating data</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>65536 (64 kibibytes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.socket.timeout.ms"></a><a id="brokerconfigs_replica.socket.timeout.ms" href="#brokerconfigs_replica.socket.timeout.ms">replica.socket.timeout.ms</a></h4>
<p>The socket timeout for network requests. Its value should be at least replica.fetch.wait.max.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="request.timeout.ms"></a><a id="brokerconfigs_request.timeout.ms" href="#brokerconfigs_request.timeout.ms">request.timeout.ms</a></h4>
<p>The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.mechanism.controller.protocol"></a><a id="brokerconfigs_sasl.mechanism.controller.protocol" href="#brokerconfigs_sasl.mechanism.controller.protocol">sasl.mechanism.controller.protocol</a></h4>
<p>SASL mechanism used for communication with controllers. Default is GSSAPI.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>GSSAPI</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.load.buffer.size"></a><a id="brokerconfigs_share.coordinator.load.buffer.size" href="#brokerconfigs_share.coordinator.load.buffer.size">share.coordinator.load.buffer.size</a></h4>
<p>Batch size for reading from the share-group state topic when loading state information into the cache (soft-limit, overridden if records are too large).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5242880</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.state.topic.compression.codec"></a><a id="brokerconfigs_share.coordinator.state.topic.compression.codec" href="#brokerconfigs_share.coordinator.state.topic.compression.codec">share.coordinator.state.topic.compression.codec</a></h4>
<p>Compression codec for the share-group state topic.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.state.topic.min.isr"></a><a id="brokerconfigs_share.coordinator.state.topic.min.isr" href="#brokerconfigs_share.coordinator.state.topic.min.isr">share.coordinator.state.topic.min.isr</a></h4>
<p>Overridden min.insync.replicas for the share-group state topic.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.state.topic.num.partitions"></a><a id="brokerconfigs_share.coordinator.state.topic.num.partitions" href="#brokerconfigs_share.coordinator.state.topic.num.partitions">share.coordinator.state.topic.num.partitions</a></h4>
<p>The number of partitions for the share-group state topic (should not change after deployment).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>50</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.state.topic.replication.factor"></a><a id="brokerconfigs_share.coordinator.state.topic.replication.factor" href="#brokerconfigs_share.coordinator.state.topic.replication.factor">share.coordinator.state.topic.replication.factor</a></h4>
<p>Replication factor for the share-group state topic. Topic creation will fail until the cluster size meets this replication factor requirement.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>3</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.state.topic.segment.bytes"></a><a id="brokerconfigs_share.coordinator.state.topic.segment.bytes" href="#brokerconfigs_share.coordinator.state.topic.segment.bytes">share.coordinator.state.topic.segment.bytes</a></h4>
<p>The log segment size for the share-group state topic.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>104857600 (100 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.write.timeout.ms"></a><a id="brokerconfigs_share.coordinator.write.timeout.ms" href="#brokerconfigs_share.coordinator.write.timeout.ms">share.coordinator.write.timeout.ms</a></h4>
<p>The duration in milliseconds that the share coordinator will wait for all replicas of the share-group state topic to receive a write.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.receive.buffer.bytes"></a><a id="brokerconfigs_socket.receive.buffer.bytes" href="#brokerconfigs_socket.receive.buffer.bytes">socket.receive.buffer.bytes</a></h4>
<p>The SO_RCVBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>102400 (100 kibibytes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.request.max.bytes"></a><a id="brokerconfigs_socket.request.max.bytes" href="#brokerconfigs_socket.request.max.bytes">socket.request.max.bytes</a></h4>
<p>The maximum number of bytes in a socket request</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>104857600 (100 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.send.buffer.bytes"></a><a id="brokerconfigs_socket.send.buffer.bytes" href="#brokerconfigs_socket.send.buffer.bytes">socket.send.buffer.bytes</a></h4>
<p>The SO_SNDBUF buffer of the socket server sockets. If the value is -1, the OS default will be used.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>102400 (100 kibibytes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.max.timeout.ms"></a><a id="brokerconfigs_transaction.max.timeout.ms" href="#brokerconfigs_transaction.max.timeout.ms">transaction.max.timeout.ms</a></h4>
<p>The maximum allowed timeout for transactions. If a clients requested transaction time exceed this, then the broker will return an error in InitProducerIdRequest. This prevents a client from too large of a timeout, which can stall consumers reading from topics included in the transaction.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>900000 (15 minutes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.state.log.load.buffer.size"></a><a id="brokerconfigs_transaction.state.log.load.buffer.size" href="#brokerconfigs_transaction.state.log.load.buffer.size">transaction.state.log.load.buffer.size</a></h4>
<p>Batch size for reading from the transaction log segments when loading producer ids and transactions into the cache (soft-limit, overridden if records are too large).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5242880</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.state.log.min.isr"></a><a id="brokerconfigs_transaction.state.log.min.isr" href="#brokerconfigs_transaction.state.log.min.isr">transaction.state.log.min.isr</a></h4>
<p>The minimum number of replicas that must acknowledge a write to transaction topic in order to be considered successful.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.state.log.num.partitions"></a><a id="brokerconfigs_transaction.state.log.num.partitions" href="#brokerconfigs_transaction.state.log.num.partitions">transaction.state.log.num.partitions</a></h4>
<p>The number of partitions for the transaction topic (should not change after deployment).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>50</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.state.log.replication.factor"></a><a id="brokerconfigs_transaction.state.log.replication.factor" href="#brokerconfigs_transaction.state.log.replication.factor">transaction.state.log.replication.factor</a></h4>
<p>The replication factor for the transaction topic (set higher to ensure availability). Internal topic creation will fail until the cluster size meets this replication factor requirement.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>3</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.state.log.segment.bytes"></a><a id="brokerconfigs_transaction.state.log.segment.bytes" href="#brokerconfigs_transaction.state.log.segment.bytes">transaction.state.log.segment.bytes</a></h4>
<p>The transaction topic segment bytes should be kept relatively small in order to facilitate faster log compaction and cache loads</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>104857600 (100 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transactional.id.expiration.ms"></a><a id="brokerconfigs_transactional.id.expiration.ms" href="#brokerconfigs_transactional.id.expiration.ms">transactional.id.expiration.ms</a></h4>
<p>The time in ms that the transaction coordinator will wait without receiving any transaction status updates for the current transaction before expiring its transactional id. Transactional IDs will not expire while a the transaction is still ongoing.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>604800000 (7 days)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="unclean.leader.election.enable"></a><a id="brokerconfigs_unclean.leader.election.enable" href="#brokerconfigs_unclean.leader.election.enable">unclean.leader.election.enable</a></h4>
<p>Indicates whether to enable replicas not in the ISR set to be elected as leader as a last resort, even though doing so may result in data loss<p>Note: In KRaft mode, when enabling this config dynamically, it needs to wait for the unclean leader election thread to trigger election periodically (default is 5 minutes). Please run `kafka-leader-election.sh` with `unclean` option to trigger the unclean leader election immediately if needed.</p></p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>high</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="broker.heartbeat.interval.ms"></a><a id="brokerconfigs_broker.heartbeat.interval.ms" href="#brokerconfigs_broker.heartbeat.interval.ms">broker.heartbeat.interval.ms</a></h4>
<p>The length of time in milliseconds between broker heartbeats.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000 (2 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="broker.rack"></a><a id="brokerconfigs_broker.rack" href="#brokerconfigs_broker.rack">broker.rack</a></h4>
<p>Rack of the broker. This will be used in rack aware replication assignment for fault tolerance. Examples: <code>RACK1</code>, <code>us-east-1d</code></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="broker.session.timeout.ms"></a><a id="brokerconfigs_broker.session.timeout.ms" href="#brokerconfigs_broker.session.timeout.ms">broker.session.timeout.ms</a></h4>
<p>The length of time in milliseconds that a broker lease lasts if no heartbeats are made.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>9000 (9 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="compression.gzip.level"></a><a id="brokerconfigs_compression.gzip.level" href="#brokerconfigs_compression.gzip.level">compression.gzip.level</a></h4>
<p>The compression level to use if compression.type is set to 'gzip'.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>-1</td></tr>
<tr><th>Valid Values:</th><td>[1,...,9] or -1</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="compression.lz4.level"></a><a id="brokerconfigs_compression.lz4.level" href="#brokerconfigs_compression.lz4.level">compression.lz4.level</a></h4>
<p>The compression level to use if compression.type is set to 'lz4'.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>9</td></tr>
<tr><th>Valid Values:</th><td>[1,...,17]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="compression.zstd.level"></a><a id="brokerconfigs_compression.zstd.level" href="#brokerconfigs_compression.zstd.level">compression.zstd.level</a></h4>
<p>The compression level to use if compression.type is set to 'zstd'.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>3</td></tr>
<tr><th>Valid Values:</th><td>[-131072,...,22]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="connections.max.idle.ms"></a><a id="brokerconfigs_connections.max.idle.ms" href="#brokerconfigs_connections.max.idle.ms">connections.max.idle.ms</a></h4>
<p>Idle connections timeout: the server socket processor threads close the connections that idle more than this</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>600000 (10 minutes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="connections.max.reauth.ms"></a><a id="brokerconfigs_connections.max.reauth.ms" href="#brokerconfigs_connections.max.reauth.ms">connections.max.reauth.ms</a></h4>
<p>When explicitly set to a positive number (the default is 0, not a positive number), a session lifetime that will not exceed the configured value will be communicated to v2.2.0 or later clients when they authenticate. The broker will disconnect any such connection that is not re-authenticated within the session lifetime and that is then subsequently used for any purpose other than re-authentication. Configuration names can optionally be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.oauthbearer.connections.max.reauth.ms=3600000</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controlled.shutdown.enable"></a><a id="brokerconfigs_controlled.shutdown.enable" href="#brokerconfigs_controlled.shutdown.enable">controlled.shutdown.enable</a></h4>
<p>Enable controlled shutdown of the server.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.append.linger.ms"></a><a id="brokerconfigs_controller.quorum.append.linger.ms" href="#brokerconfigs_controller.quorum.append.linger.ms">controller.quorum.append.linger.ms</a></h4>
<p>The duration in milliseconds that the leader will wait for writes to accumulate before flushing them to disk.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>25</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.request.timeout.ms"></a><a id="brokerconfigs_controller.quorum.request.timeout.ms" href="#brokerconfigs_controller.quorum.request.timeout.ms">controller.quorum.request.timeout.ms</a></h4>
<p>The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000 (2 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.socket.timeout.ms"></a><a id="brokerconfigs_controller.socket.timeout.ms" href="#brokerconfigs_controller.socket.timeout.ms">controller.socket.timeout.ms</a></h4>
<p>The socket timeout for controller-to-broker channels.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="default.replication.factor"></a><a id="brokerconfigs_default.replication.factor" href="#brokerconfigs_default.replication.factor">default.replication.factor</a></h4>
<p>The replication factor for automatically created topics, and for topics created with -1 as the replication factor</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delegation.token.expiry.time.ms"></a><a id="brokerconfigs_delegation.token.expiry.time.ms" href="#brokerconfigs_delegation.token.expiry.time.ms">delegation.token.expiry.time.ms</a></h4>
<p>The token validity time in milliseconds before the token needs to be renewed. Default value 1 day.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>86400000 (1 day)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delegation.token.max.lifetime.ms"></a><a id="brokerconfigs_delegation.token.max.lifetime.ms" href="#brokerconfigs_delegation.token.max.lifetime.ms">delegation.token.max.lifetime.ms</a></h4>
<p>The token has a maximum lifetime beyond which it cannot be renewed anymore. Default value 7 days.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>604800000 (7 days)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delegation.token.secret.key"></a><a id="brokerconfigs_delegation.token.secret.key" href="#brokerconfigs_delegation.token.secret.key">delegation.token.secret.key</a></h4>
<p>Secret key to generate and verify delegation tokens. The same key must be configured across all the brokers.  If using Kafka with KRaft, the key must also be set across all controllers.  If the key is not set or set to empty string, brokers will disable the delegation token support.</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delete.records.purgatory.purge.interval.requests"></a><a id="brokerconfigs_delete.records.purgatory.purge.interval.requests" href="#brokerconfigs_delete.records.purgatory.purge.interval.requests">delete.records.purgatory.purge.interval.requests</a></h4>
<p>The purge interval (in number of requests) of the delete records request purgatory</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="fetch.max.bytes"></a><a id="brokerconfigs_fetch.max.bytes" href="#brokerconfigs_fetch.max.bytes">fetch.max.bytes</a></h4>
<p>The maximum number of bytes we will return for a fetch request. Must be at least 1024.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>57671680 (55 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[1024,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="fetch.purgatory.purge.interval.requests"></a><a id="brokerconfigs_fetch.purgatory.purge.interval.requests" href="#brokerconfigs_fetch.purgatory.purge.interval.requests">fetch.purgatory.purge.interval.requests</a></h4>
<p>The purge interval (in number of requests) of the fetch request purgatory</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.assignors"></a><a id="brokerconfigs_group.consumer.assignors" href="#brokerconfigs_group.consumer.assignors">group.consumer.assignors</a></h4>
<p>The server side assignors as a list of either names for builtin assignors or full class names for customer assignors. The first one in the list is considered as the default assignor to be used in the case where the consumer does not specify an assignor. The supported builtin assignors are: uniform, range.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>uniform,range</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.heartbeat.interval.ms"></a><a id="brokerconfigs_group.consumer.heartbeat.interval.ms" href="#brokerconfigs_group.consumer.heartbeat.interval.ms">group.consumer.heartbeat.interval.ms</a></h4>
<p>The heartbeat interval given to the members of a consumer group.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.max.heartbeat.interval.ms"></a><a id="brokerconfigs_group.consumer.max.heartbeat.interval.ms" href="#brokerconfigs_group.consumer.max.heartbeat.interval.ms">group.consumer.max.heartbeat.interval.ms</a></h4>
<p>The maximum heartbeat interval for registered consumers.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>15000 (15 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.max.session.timeout.ms"></a><a id="brokerconfigs_group.consumer.max.session.timeout.ms" href="#brokerconfigs_group.consumer.max.session.timeout.ms">group.consumer.max.session.timeout.ms</a></h4>
<p>The maximum allowed session timeout for registered consumers.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.max.size"></a><a id="brokerconfigs_group.consumer.max.size" href="#brokerconfigs_group.consumer.max.size">group.consumer.max.size</a></h4>
<p>The maximum number of consumers that a single consumer group can accommodate. This value will only impact groups under the CONSUMER group protocol. To configure the max group size when using the CLASSIC group protocol use group.max.size instead.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.migration.policy"></a><a id="brokerconfigs_group.consumer.migration.policy" href="#brokerconfigs_group.consumer.migration.policy">group.consumer.migration.policy</a></h4>
<p>The config that enables converting the non-empty classic group using the consumer embedded protocol to the non-empty consumer group using the consumer group protocol and vice versa; conversions of empty groups in both directions are always enabled regardless of this policy. bidirectional: both upgrade from classic group to consumer group and downgrade from consumer group to classic group are enabled, upgrade: only upgrade from classic group to consumer group is enabled, downgrade: only downgrade from consumer group to classic group is enabled, disabled: neither upgrade nor downgrade is enabled.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>bidirectional</td></tr>
<tr><th>Valid Values:</th><td>(case insensitive) [DISABLED, DOWNGRADE, UPGRADE, BIDIRECTIONAL]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.min.heartbeat.interval.ms"></a><a id="brokerconfigs_group.consumer.min.heartbeat.interval.ms" href="#brokerconfigs_group.consumer.min.heartbeat.interval.ms">group.consumer.min.heartbeat.interval.ms</a></h4>
<p>The minimum heartbeat interval for registered consumers.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.min.session.timeout.ms"></a><a id="brokerconfigs_group.consumer.min.session.timeout.ms" href="#brokerconfigs_group.consumer.min.session.timeout.ms">group.consumer.min.session.timeout.ms</a></h4>
<p>The minimum allowed session timeout for registered consumers.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.consumer.session.timeout.ms"></a><a id="brokerconfigs_group.consumer.session.timeout.ms" href="#brokerconfigs_group.consumer.session.timeout.ms">group.consumer.session.timeout.ms</a></h4>
<p>The timeout to detect client failures when using the consumer group protocol.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.coordinator.append.linger.ms"></a><a id="brokerconfigs_group.coordinator.append.linger.ms" href="#brokerconfigs_group.coordinator.append.linger.ms">group.coordinator.append.linger.ms</a></h4>
<p>The duration in milliseconds that the coordinator will wait for writes to accumulate before flushing them to disk. Increasing this value improves write efficiency and batch size, but also increases the response latency for requests, as the coordinator must wait for batches to be flushed to disk before completing request processing. Transactional writes are not accumulated.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.coordinator.rebalance.protocols"></a><a id="brokerconfigs_group.coordinator.rebalance.protocols" href="#brokerconfigs_group.coordinator.rebalance.protocols">group.coordinator.rebalance.protocols</a></h4>
<p>The list of enabled rebalance protocols.The streams rebalance protocol is in early access and therefore must not be used in production.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>classic,consumer,streams</td></tr>
<tr><th>Valid Values:</th><td>[consumer, classic, share, streams]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.initial.rebalance.delay.ms"></a><a id="brokerconfigs_group.initial.rebalance.delay.ms" href="#brokerconfigs_group.initial.rebalance.delay.ms">group.initial.rebalance.delay.ms</a></h4>
<p>The amount of time the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>3000 (3 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.max.session.timeout.ms"></a><a id="brokerconfigs_group.max.session.timeout.ms" href="#brokerconfigs_group.max.session.timeout.ms">group.max.session.timeout.ms</a></h4>
<p>The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1800000 (30 minutes)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.max.size"></a><a id="brokerconfigs_group.max.size" href="#brokerconfigs_group.max.size">group.max.size</a></h4>
<p>The maximum number of consumers that a single consumer group can accommodate.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.min.session.timeout.ms"></a><a id="brokerconfigs_group.min.session.timeout.ms" href="#brokerconfigs_group.min.session.timeout.ms">group.min.session.timeout.ms</a></h4>
<p>The minimum allowed session timeout for registered consumers. Shorter timeouts result in quicker failure detection at the cost of more frequent consumer heartbeating, which can overwhelm broker resources.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>6000 (6 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.assignors"></a><a id="brokerconfigs_group.share.assignors" href="#brokerconfigs_group.share.assignors">group.share.assignors</a></h4>
<p>The server-side assignors as a list of either names for built-in assignors or full class names for custom assignors. The list must contain only a single entry which is used by all groups. The supported built-in assignors are: simple.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>simple</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.delivery.count.limit"></a><a id="brokerconfigs_group.share.delivery.count.limit" href="#brokerconfigs_group.share.delivery.count.limit">group.share.delivery.count.limit</a></h4>
<p>The maximum number of delivery attempts for a record delivered to a share group.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5</td></tr>
<tr><th>Valid Values:</th><td>[2,...,10]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.heartbeat.interval.ms"></a><a id="brokerconfigs_group.share.heartbeat.interval.ms" href="#brokerconfigs_group.share.heartbeat.interval.ms">group.share.heartbeat.interval.ms</a></h4>
<p>The heartbeat interval given to the members of a share group.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.max.heartbeat.interval.ms"></a><a id="brokerconfigs_group.share.max.heartbeat.interval.ms" href="#brokerconfigs_group.share.max.heartbeat.interval.ms">group.share.max.heartbeat.interval.ms</a></h4>
<p>The maximum heartbeat interval for share group members.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>15000 (15 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.max.record.lock.duration.ms"></a><a id="brokerconfigs_group.share.max.record.lock.duration.ms" href="#brokerconfigs_group.share.max.record.lock.duration.ms">group.share.max.record.lock.duration.ms</a></h4>
<p>The record acquisition lock maximum duration in milliseconds for share groups.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[30000,...,3600000]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.max.session.timeout.ms"></a><a id="brokerconfigs_group.share.max.session.timeout.ms" href="#brokerconfigs_group.share.max.session.timeout.ms">group.share.max.session.timeout.ms</a></h4>
<p>The maximum allowed session timeout for share group members.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.max.share.sessions"></a><a id="brokerconfigs_group.share.max.share.sessions" href="#brokerconfigs_group.share.max.share.sessions">group.share.max.share.sessions</a></h4>
<p>The maximum number of share sessions per broker.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.max.size"></a><a id="brokerconfigs_group.share.max.size" href="#brokerconfigs_group.share.max.size">group.share.max.size</a></h4>
<p>The maximum number of members that a single share group can accommodate.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>200</td></tr>
<tr><th>Valid Values:</th><td>[1,...,1000]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.min.heartbeat.interval.ms"></a><a id="brokerconfigs_group.share.min.heartbeat.interval.ms" href="#brokerconfigs_group.share.min.heartbeat.interval.ms">group.share.min.heartbeat.interval.ms</a></h4>
<p>The minimum heartbeat interval for share group members.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.min.record.lock.duration.ms"></a><a id="brokerconfigs_group.share.min.record.lock.duration.ms" href="#brokerconfigs_group.share.min.record.lock.duration.ms">group.share.min.record.lock.duration.ms</a></h4>
<p>The record acquisition lock minimum duration in milliseconds for share groups.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>15000 (15 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1000,...,30000]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.min.session.timeout.ms"></a><a id="brokerconfigs_group.share.min.session.timeout.ms" href="#brokerconfigs_group.share.min.session.timeout.ms">group.share.min.session.timeout.ms</a></h4>
<p>The minimum allowed session timeout for share group members.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.partition.max.record.locks"></a><a id="brokerconfigs_group.share.partition.max.record.locks" href="#brokerconfigs_group.share.partition.max.record.locks">group.share.partition.max.record.locks</a></h4>
<p>Share-group record lock limit per share-partition.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000</td></tr>
<tr><th>Valid Values:</th><td>[100,...,10000]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.record.lock.duration.ms"></a><a id="brokerconfigs_group.share.record.lock.duration.ms" href="#brokerconfigs_group.share.record.lock.duration.ms">group.share.record.lock.duration.ms</a></h4>
<p>The record acquisition lock duration in milliseconds for share groups.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1000,...,3600000]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.share.session.timeout.ms"></a><a id="brokerconfigs_group.share.session.timeout.ms" href="#brokerconfigs_group.share.session.timeout.ms">group.share.session.timeout.ms</a></h4>
<p>The timeout to detect client failures when using the share group protocol.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.heartbeat.interval.ms"></a><a id="brokerconfigs_group.streams.heartbeat.interval.ms" href="#brokerconfigs_group.streams.heartbeat.interval.ms">group.streams.heartbeat.interval.ms</a></h4>
<p>The heartbeat interval given to the members.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.max.heartbeat.interval.ms"></a><a id="brokerconfigs_group.streams.max.heartbeat.interval.ms" href="#brokerconfigs_group.streams.max.heartbeat.interval.ms">group.streams.max.heartbeat.interval.ms</a></h4>
<p>The maximum allowed value for the group-level configuration of streams.heartbeat.interval.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>15000 (15 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.max.session.timeout.ms"></a><a id="brokerconfigs_group.streams.max.session.timeout.ms" href="#brokerconfigs_group.streams.max.session.timeout.ms">group.streams.max.session.timeout.ms</a></h4>
<p>The maximum allowed value for the group-level configuration of streams.session.timeout.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.max.size"></a><a id="brokerconfigs_group.streams.max.size" href="#brokerconfigs_group.streams.max.size">group.streams.max.size</a></h4>
<p>The maximum number of streams clients that a single streams group can accommodate.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.max.standby.replicas"></a><a id="brokerconfigs_group.streams.max.standby.replicas" href="#brokerconfigs_group.streams.max.standby.replicas">group.streams.max.standby.replicas</a></h4>
<p>The maximum allowed value for the group-level configuration of streams.num.standby.replicas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.min.heartbeat.interval.ms"></a><a id="brokerconfigs_group.streams.min.heartbeat.interval.ms" href="#brokerconfigs_group.streams.min.heartbeat.interval.ms">group.streams.min.heartbeat.interval.ms</a></h4>
<p>The minimum allowed value for the group-level configuration of streams.heartbeat.interval.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5000 (5 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.min.session.timeout.ms"></a><a id="brokerconfigs_group.streams.min.session.timeout.ms" href="#brokerconfigs_group.streams.min.session.timeout.ms">group.streams.min.session.timeout.ms</a></h4>
<p>The minimum allowed value for the group-level configuration of streams.session.timeout.ms</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.num.standby.replicas"></a><a id="brokerconfigs_group.streams.num.standby.replicas" href="#brokerconfigs_group.streams.num.standby.replicas">group.streams.num.standby.replicas</a></h4>
<p>The number of standby replicas for each task.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="group.streams.session.timeout.ms"></a><a id="brokerconfigs_group.streams.session.timeout.ms" href="#brokerconfigs_group.streams.session.timeout.ms">group.streams.session.timeout.ms</a></h4>
<p>The timeout to detect client failures when using the streams group protocol.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>45000 (45 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="initial.broker.registration.timeout.ms"></a><a id="brokerconfigs_initial.broker.registration.timeout.ms" href="#brokerconfigs_initial.broker.registration.timeout.ms">initial.broker.registration.timeout.ms</a></h4>
<p>When initially registering with the controller quorum, the number of milliseconds to wait before declaring failure and exiting the broker process.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60000 (1 minute)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="inter.broker.listener.name"></a><a id="brokerconfigs_inter.broker.listener.name" href="#brokerconfigs_inter.broker.listener.name">inter.broker.listener.name</a></h4>
<p>Name of listener used for communication between brokers. If this is unset, the listener name is defined by security.inter.broker.protocol. It is an error to set this and security.inter.broker.protocol properties at the same time.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.backoff.ms"></a><a id="brokerconfigs_log.cleaner.backoff.ms" href="#brokerconfigs_log.cleaner.backoff.ms">log.cleaner.backoff.ms</a></h4>
<p>The amount of time to sleep when there are no logs to clean</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>15000 (15 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.dedupe.buffer.size"></a><a id="brokerconfigs_log.cleaner.dedupe.buffer.size" href="#brokerconfigs_log.cleaner.dedupe.buffer.size">log.cleaner.dedupe.buffer.size</a></h4>
<p>The total memory used for log deduplication across all cleaner threads</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>134217728</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.delete.retention.ms"></a><a id="brokerconfigs_log.cleaner.delete.retention.ms" href="#brokerconfigs_log.cleaner.delete.retention.ms">log.cleaner.delete.retention.ms</a></h4>
<p>The amount of time to retain tombstone message markers for log compacted topics. This setting also gives a bound on the time in which a consumer must complete a read if they begin from offset 0 to ensure that they get a valid snapshot of the final stage (otherwise  tombstones messages may be collected before a consumer completes their scan).</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>86400000 (1 day)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.enable"></a><a id="brokerconfigs_log.cleaner.enable" href="#brokerconfigs_log.cleaner.enable">log.cleaner.enable</a></h4>
<p>This configuration has been deprecated and will be removed in Kafka 5.0. Users should not set it to false to prepare for its future removal. Enable the log cleaner process to run on the server. Should be enabled if using any topics with a cleanup.policy=compact including the internal offsets topic. If disabled those topics will not be compacted and continually grow in size.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.io.buffer.load.factor"></a><a id="brokerconfigs_log.cleaner.io.buffer.load.factor" href="#brokerconfigs_log.cleaner.io.buffer.load.factor">log.cleaner.io.buffer.load.factor</a></h4>
<p>Log cleaner dedupe buffer load factor. The percentage full the dedupe buffer can become. A higher value will allow more log to be cleaned at once but will lead to more hash collisions</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.9</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.io.buffer.size"></a><a id="brokerconfigs_log.cleaner.io.buffer.size" href="#brokerconfigs_log.cleaner.io.buffer.size">log.cleaner.io.buffer.size</a></h4>
<p>The total memory used for log cleaner I/O buffers across all cleaner threads</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>524288</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.io.max.bytes.per.second"></a><a id="brokerconfigs_log.cleaner.io.max.bytes.per.second" href="#brokerconfigs_log.cleaner.io.max.bytes.per.second">log.cleaner.io.max.bytes.per.second</a></h4>
<p>The log cleaner will be throttled so that the sum of its read and write i/o will be less than this value on average</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>1.7976931348623157E308</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.max.compaction.lag.ms"></a><a id="brokerconfigs_log.cleaner.max.compaction.lag.ms" href="#brokerconfigs_log.cleaner.max.compaction.lag.ms">log.cleaner.max.compaction.lag.ms</a></h4>
<p>The maximum time a message will remain ineligible for compaction in the log. Only applicable for logs that are being compacted.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.min.cleanable.ratio"></a><a id="brokerconfigs_log.cleaner.min.cleanable.ratio" href="#brokerconfigs_log.cleaner.min.cleanable.ratio">log.cleaner.min.cleanable.ratio</a></h4>
<p>The minimum ratio of dirty log to total log for a log to eligible for cleaning. If the log.cleaner.max.compaction.lag.ms or the log.cleaner.min.compaction.lag.ms configurations are also specified, then the log compactor considers the log eligible for compaction as soon as either: (i) the dirty ratio threshold has been met and the log has had dirty (uncompacted) records for at least the log.cleaner.min.compaction.lag.ms duration, or (ii) if the log has had dirty (uncompacted) records for at most the log.cleaner.max.compaction.lag.ms period.</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.5</td></tr>
<tr><th>Valid Values:</th><td>[0,...,1]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.min.compaction.lag.ms"></a><a id="brokerconfigs_log.cleaner.min.compaction.lag.ms" href="#brokerconfigs_log.cleaner.min.compaction.lag.ms">log.cleaner.min.compaction.lag.ms</a></h4>
<p>The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>0</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleaner.threads"></a><a id="brokerconfigs_log.cleaner.threads" href="#brokerconfigs_log.cleaner.threads">log.cleaner.threads</a></h4>
<p>The number of background threads to use for log cleaning</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.cleanup.policy"></a><a id="brokerconfigs_log.cleanup.policy" href="#brokerconfigs_log.cleanup.policy">log.cleanup.policy</a></h4>
<p>The default cleanup policy for segments beyond the retention window. A comma separated list of valid policies.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>delete</td></tr>
<tr><th>Valid Values:</th><td>[compact, delete]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.index.interval.bytes"></a><a id="brokerconfigs_log.index.interval.bytes" href="#brokerconfigs_log.index.interval.bytes">log.index.interval.bytes</a></h4>
<p>The interval with which we add an entry to the offset index.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>4096 (4 kibibytes)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.index.size.max.bytes"></a><a id="brokerconfigs_log.index.size.max.bytes" href="#brokerconfigs_log.index.size.max.bytes">log.index.size.max.bytes</a></h4>
<p>The maximum size in bytes of the offset index</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10485760 (10 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[4,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.local.retention.bytes"></a><a id="brokerconfigs_log.local.retention.bytes" href="#brokerconfigs_log.local.retention.bytes">log.local.retention.bytes</a></h4>
<p>The maximum size of local log segments that can grow for a partition before it gets eligible for deletion. Default value is -2, it represents `log.retention.bytes` value to be used. The effective value should always be less than or equal to `log.retention.bytes` value.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>-2</td></tr>
<tr><th>Valid Values:</th><td>[-2,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.local.retention.ms"></a><a id="brokerconfigs_log.local.retention.ms" href="#brokerconfigs_log.local.retention.ms">log.local.retention.ms</a></h4>
<p>The number of milliseconds to keep the local log segments before it gets eligible for deletion. Default value is -2, it represents `log.retention.ms` value is to be used. The effective value should always be less than or equal to `log.retention.ms` value.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>-2</td></tr>
<tr><th>Valid Values:</th><td>[-2,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.message.timestamp.after.max.ms"></a><a id="brokerconfigs_log.message.timestamp.after.max.ms" href="#brokerconfigs_log.message.timestamp.after.max.ms">log.message.timestamp.after.max.ms</a></h4>
<p>This configuration sets the allowable timestamp difference between the message timestamp and the broker's timestamp. The message timestamp can be later than or equal to the broker's timestamp, with the maximum allowable difference determined by the value set in this configuration. If log.message.timestamp.type=CreateTime, the message will be rejected if the difference in timestamps exceeds this specified threshold. This configuration is ignored if log.message.timestamp.type=LogAppendTime.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>3600000 (1 hour)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.message.timestamp.before.max.ms"></a><a id="brokerconfigs_log.message.timestamp.before.max.ms" href="#brokerconfigs_log.message.timestamp.before.max.ms">log.message.timestamp.before.max.ms</a></h4>
<p>This configuration sets the allowable timestamp difference between the broker's timestamp and the message timestamp. The message timestamp can be earlier than or equal to the broker's timestamp, with the maximum allowable difference determined by the value set in this configuration. If log.message.timestamp.type=CreateTime, the message will be rejected if the difference in timestamps exceeds this specified threshold. This configuration is ignored if log.message.timestamp.type=LogAppendTime.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.message.timestamp.type"></a><a id="brokerconfigs_log.message.timestamp.type" href="#brokerconfigs_log.message.timestamp.type">log.message.timestamp.type</a></h4>
<p>Define whether the timestamp in the message is message create time or log append time. The value should be either <code>CreateTime</code> or <code>LogAppendTime</code>.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>CreateTime</td></tr>
<tr><th>Valid Values:</th><td>[CreateTime, LogAppendTime]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.preallocate"></a><a id="brokerconfigs_log.preallocate" href="#brokerconfigs_log.preallocate">log.preallocate</a></h4>
<p>Should pre allocate file when create new segment? If you are using Kafka on Windows, you probably need to set it to true.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.retention.check.interval.ms"></a><a id="brokerconfigs_log.retention.check.interval.ms" href="#brokerconfigs_log.retention.check.interval.ms">log.retention.check.interval.ms</a></h4>
<p>The frequency in milliseconds that the log cleaner checks whether any log is eligible for deletion</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>300000 (5 minutes)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.connection.creation.rate"></a><a id="brokerconfigs_max.connection.creation.rate" href="#brokerconfigs_max.connection.creation.rate">max.connection.creation.rate</a></h4>
<p>The maximum connection creation rate we allow in the broker at any time. Listener-level limits may also be configured by prefixing the config name with the listener prefix, for example, <code>listener.name.internal.max.connection.creation.rate</code>.Broker-wide connection rate limit should be configured based on broker capacity while listener limits should be configured based on application requirements. New connections will be throttled if either the listener or the broker limit is reached, with the exception of inter-broker listener. Connections on the inter-broker listener will be throttled only when the listener-level rate limit is reached.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.connections"></a><a id="brokerconfigs_max.connections" href="#brokerconfigs_max.connections">max.connections</a></h4>
<p>The maximum number of connections we allow in the broker at any time. This limit is applied in addition to any per-ip limits configured using max.connections.per.ip. Listener-level limits may also be configured by prefixing the config name with the listener prefix, for example, <code>listener.name.internal.max.connections.per.ip</code>. Broker-wide limit should be configured based on broker capacity while listener limits should be configured based on application requirements. New connections are blocked if either the listener or broker limit is reached. Connections on the inter-broker listener are permitted even if broker-wide limit is reached. The least recently used connection on another listener will be closed in this case.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.connections.per.ip"></a><a id="brokerconfigs_max.connections.per.ip" href="#brokerconfigs_max.connections.per.ip">max.connections.per.ip</a></h4>
<p>The maximum number of connections we allow from each ip address. This can be set to 0 if there are overrides configured using max.connections.per.ip.overrides property. New connections from the ip address are dropped if the limit is reached.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2147483647</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.connections.per.ip.overrides"></a><a id="brokerconfigs_max.connections.per.ip.overrides" href="#brokerconfigs_max.connections.per.ip.overrides">max.connections.per.ip.overrides</a></h4>
<p>A comma-separated list of per-ip or hostname overrides to the default maximum number of connections. An example value is "hostName:100,127.0.0.1:200"</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.incremental.fetch.session.cache.slots"></a><a id="brokerconfigs_max.incremental.fetch.session.cache.slots" href="#brokerconfigs_max.incremental.fetch.session.cache.slots">max.incremental.fetch.session.cache.slots</a></h4>
<p>The maximum number of total incremental fetch sessions that we will maintain. FetchSessionCache is sharded into 8 shards and the limit is equally divided among all shards. Sessions are allocated to each shard in round-robin. Only entries within a shard are considered eligible for eviction.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="max.request.partition.size.limit"></a><a id="brokerconfigs_max.request.partition.size.limit" href="#brokerconfigs_max.request.partition.size.limit">max.request.partition.size.limit</a></h4>
<p>The maximum number of partitions can be served in one request.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2000</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="num.partitions"></a><a id="brokerconfigs_num.partitions" href="#brokerconfigs_num.partitions">num.partitions</a></h4>
<p>The default number of log partitions per topic</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="principal.builder.class"></a><a id="brokerconfigs_principal.builder.class" href="#brokerconfigs_principal.builder.class">principal.builder.class</a></h4>
<p>The fully qualified name of a class that implements the KafkaPrincipalBuilder interface, which is used to build the KafkaPrincipal object used during authorization. If no principal builder is defined, the default behavior depends on the security protocol in use. For SSL authentication,  the principal will be derived using the rules defined by <code>ssl.principal.mapping.rules</code> applied on the distinguished name from the client certificate if one is provided; otherwise, if client authentication is not required, the principal name will be ANONYMOUS. For SASL authentication, the principal will be derived using the rules defined by <code>sasl.kerberos.principal.to.local.rules</code> if GSSAPI is in use, and the SASL authentication ID for other mechanisms. For PLAINTEXT, the principal will be ANONYMOUS. Note that custom implementations of <code>KafkaPrincipalBuilder</code> is required to implement <code>KafkaPrincipalSerde</code> interface, otherwise brokers will not be able to forward requests to the controller.</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="producer.purgatory.purge.interval.requests"></a><a id="brokerconfigs_producer.purgatory.purge.interval.requests" href="#brokerconfigs_producer.purgatory.purge.interval.requests">producer.purgatory.purge.interval.requests</a></h4>
<p>The purge interval (in number of requests) of the producer request purgatory</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="queued.max.request.bytes"></a><a id="brokerconfigs_queued.max.request.bytes" href="#brokerconfigs_queued.max.request.bytes">queued.max.request.bytes</a></h4>
<p>The number of queued bytes allowed before no more requests are read</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>-1</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.fetch.max.wait.ms"></a><a id="brokerconfigs_remote.fetch.max.wait.ms" href="#brokerconfigs_remote.fetch.max.wait.ms">remote.fetch.max.wait.ms</a></h4>
<p>The maximum amount of time the server will wait before answering the remote fetch request. Note that the broker currently only fetches one partition per fetch request from the remote store. (KAFKA-14915)</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>500</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.list.offsets.request.timeout.ms"></a><a id="brokerconfigs_remote.list.offsets.request.timeout.ms" href="#brokerconfigs_remote.list.offsets.request.timeout.ms">remote.list.offsets.request.timeout.ms</a></h4>
<p>The maximum amount of time the server will wait for the remote list offsets request to complete.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.copier.thread.pool.size"></a><a id="brokerconfigs_remote.log.manager.copier.thread.pool.size" href="#brokerconfigs_remote.log.manager.copier.thread.pool.size">remote.log.manager.copier.thread.pool.size</a></h4>
<p>Size of the thread pool used in scheduling tasks to copy segments.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.copy.max.bytes.per.second"></a><a id="brokerconfigs_remote.log.manager.copy.max.bytes.per.second" href="#brokerconfigs_remote.log.manager.copy.max.bytes.per.second">remote.log.manager.copy.max.bytes.per.second</a></h4>
<p>The maximum number of bytes that can be copied from local storage to remote storage per second. This is a global limit for all the partitions that are being copied from local storage to remote storage. The default value is Long.MAX_VALUE, which means there is no limit on the number of bytes that can be copied per second.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.copy.quota.window.num"></a><a id="brokerconfigs_remote.log.manager.copy.quota.window.num" href="#brokerconfigs_remote.log.manager.copy.quota.window.num">remote.log.manager.copy.quota.window.num</a></h4>
<p>The number of samples to retain in memory for remote copy quota management. The default value is 11, which means there are 10 whole windows + 1 current window.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.copy.quota.window.size.seconds"></a><a id="brokerconfigs_remote.log.manager.copy.quota.window.size.seconds" href="#brokerconfigs_remote.log.manager.copy.quota.window.size.seconds">remote.log.manager.copy.quota.window.size.seconds</a></h4>
<p>The time span of each sample for remote copy quota management. The default value is 1 second.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.expiration.thread.pool.size"></a><a id="brokerconfigs_remote.log.manager.expiration.thread.pool.size" href="#brokerconfigs_remote.log.manager.expiration.thread.pool.size">remote.log.manager.expiration.thread.pool.size</a></h4>
<p>Size of the thread pool used in scheduling tasks to clean up the expired remote log segments.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.fetch.max.bytes.per.second"></a><a id="brokerconfigs_remote.log.manager.fetch.max.bytes.per.second" href="#brokerconfigs_remote.log.manager.fetch.max.bytes.per.second">remote.log.manager.fetch.max.bytes.per.second</a></h4>
<p>The maximum number of bytes that can be fetched from remote storage to local storage per second. This is a global limit for all the partitions that are being fetched from remote storage to local storage. The default value is Long.MAX_VALUE, which means there is no limit on the number of bytes that can be fetched per second.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>9223372036854775807</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.fetch.quota.window.num"></a><a id="brokerconfigs_remote.log.manager.fetch.quota.window.num" href="#brokerconfigs_remote.log.manager.fetch.quota.window.num">remote.log.manager.fetch.quota.window.num</a></h4>
<p>The number of samples to retain in memory for remote fetch quota management. The default value is 11, which means there are 10 whole windows + 1 current window.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.fetch.quota.window.size.seconds"></a><a id="brokerconfigs_remote.log.manager.fetch.quota.window.size.seconds" href="#brokerconfigs_remote.log.manager.fetch.quota.window.size.seconds">remote.log.manager.fetch.quota.window.size.seconds</a></h4>
<p>The time span of each sample for remote fetch quota management. The default value is 1 second.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.thread.pool.size"></a><a id="brokerconfigs_remote.log.manager.thread.pool.size" href="#brokerconfigs_remote.log.manager.thread.pool.size">remote.log.manager.thread.pool.size</a></h4>
<p>Size of the thread pool used in scheduling follower tasks to read the highest-uploaded remote-offset for follower partitions.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.metadata.manager.class.name"></a><a id="brokerconfigs_remote.log.metadata.manager.class.name" href="#brokerconfigs_remote.log.metadata.manager.class.name">remote.log.metadata.manager.class.name</a></h4>
<p>Fully qualified class name of `RemoteLogMetadataManager` implementation.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>org.apache.kafka.server.log.remote.metadata.storage.TopicBasedRemoteLogMetadataManager</td></tr>
<tr><th>Valid Values:</th><td>non-empty string</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.metadata.manager.class.path"></a><a id="brokerconfigs_remote.log.metadata.manager.class.path" href="#brokerconfigs_remote.log.metadata.manager.class.path">remote.log.metadata.manager.class.path</a></h4>
<p>Class path of the `RemoteLogMetadataManager` implementation. If specified, the RemoteLogMetadataManager implementation and its dependent libraries will be loaded by a dedicated classloader which searches this class path before the Kafka broker class path. The syntax of this parameter is same as the standard Java class path string.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.metadata.manager.impl.prefix"></a><a id="brokerconfigs_remote.log.metadata.manager.impl.prefix" href="#brokerconfigs_remote.log.metadata.manager.impl.prefix">remote.log.metadata.manager.impl.prefix</a></h4>
<p>Prefix used for properties to be passed to RemoteLogMetadataManager implementation. For example this value can be `rlmm.config.`.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>rlmm.config.</td></tr>
<tr><th>Valid Values:</th><td>non-empty string</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.metadata.manager.listener.name"></a><a id="brokerconfigs_remote.log.metadata.manager.listener.name" href="#brokerconfigs_remote.log.metadata.manager.listener.name">remote.log.metadata.manager.listener.name</a></h4>
<p>Listener name of the local broker to which it should get connected if needed by RemoteLogMetadataManager implementation.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td>non-empty string</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.reader.max.pending.tasks"></a><a id="brokerconfigs_remote.log.reader.max.pending.tasks" href="#brokerconfigs_remote.log.reader.max.pending.tasks">remote.log.reader.max.pending.tasks</a></h4>
<p>Maximum remote log reader thread pool task queue size. If the task queue is full, fetch requests are served with an error.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>100</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.reader.threads"></a><a id="brokerconfigs_remote.log.reader.threads" href="#brokerconfigs_remote.log.reader.threads">remote.log.reader.threads</a></h4>
<p>Size of the thread pool that is allocated for handling remote log reads.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.storage.manager.class.name"></a><a id="brokerconfigs_remote.log.storage.manager.class.name" href="#brokerconfigs_remote.log.storage.manager.class.name">remote.log.storage.manager.class.name</a></h4>
<p>Fully qualified class name of `RemoteStorageManager` implementation.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td>non-empty string</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.storage.manager.class.path"></a><a id="brokerconfigs_remote.log.storage.manager.class.path" href="#brokerconfigs_remote.log.storage.manager.class.path">remote.log.storage.manager.class.path</a></h4>
<p>Class path of the `RemoteStorageManager` implementation. If specified, the RemoteStorageManager implementation and its dependent libraries will be loaded by a dedicated classloader which searches this class path before the Kafka broker class path. The syntax of this parameter is same as the standard Java class path string.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.storage.manager.impl.prefix"></a><a id="brokerconfigs_remote.log.storage.manager.impl.prefix" href="#brokerconfigs_remote.log.storage.manager.impl.prefix">remote.log.storage.manager.impl.prefix</a></h4>
<p>Prefix used for properties to be passed to RemoteStorageManager implementation. For example this value can be `rsm.config.`.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>rsm.config.</td></tr>
<tr><th>Valid Values:</th><td>non-empty string</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.storage.system.enable"></a><a id="brokerconfigs_remote.log.storage.system.enable" href="#brokerconfigs_remote.log.storage.system.enable">remote.log.storage.system.enable</a></h4>
<p>Whether to enable tiered storage functionality in a broker or not. When it is true broker starts all the services required for the tiered storage functionality.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.fetch.backoff.ms"></a><a id="brokerconfigs_replica.fetch.backoff.ms" href="#brokerconfigs_replica.fetch.backoff.ms">replica.fetch.backoff.ms</a></h4>
<p>The amount of time to sleep when fetch partition error occurs.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000 (1 second)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.fetch.max.bytes"></a><a id="brokerconfigs_replica.fetch.max.bytes" href="#brokerconfigs_replica.fetch.max.bytes">replica.fetch.max.bytes</a></h4>
<p>The number of bytes of messages to attempt to fetch for each partition. This is not an absolute maximum, if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. The maximum record batch size accepted by the broker is defined via <code>message.max.bytes</code> (broker config) or <code>max.message.bytes</code> (topic config).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1048576 (1 mebibyte)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.fetch.response.max.bytes"></a><a id="brokerconfigs_replica.fetch.response.max.bytes" href="#brokerconfigs_replica.fetch.response.max.bytes">replica.fetch.response.max.bytes</a></h4>
<p>Maximum bytes expected for the entire fetch response. Records are fetched in batches, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that progress can be made. As such, this is not an absolute maximum. The maximum record batch size accepted by the broker is defined via <code>message.max.bytes</code> (broker config) or <code>max.message.bytes</code> (topic config).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10485760 (10 mebibytes)</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replica.selector.class"></a><a id="brokerconfigs_replica.selector.class" href="#brokerconfigs_replica.selector.class">replica.selector.class</a></h4>
<p>The fully qualified class name that implements ReplicaSelector. This is used by the broker to find the preferred read replica. By default, we use an implementation that returns the leader.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.client.callback.handler.class"></a><a id="brokerconfigs_sasl.client.callback.handler.class" href="#brokerconfigs_sasl.client.callback.handler.class">sasl.client.callback.handler.class</a></h4>
<p>The fully qualified name of a SASL client callback handler class that implements the AuthenticateCallbackHandler interface.</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.enabled.mechanisms"></a><a id="brokerconfigs_sasl.enabled.mechanisms" href="#brokerconfigs_sasl.enabled.mechanisms">sasl.enabled.mechanisms</a></h4>
<p>The list of SASL mechanisms enabled in the Kafka server. The list may contain any mechanism for which a security provider is available. Only GSSAPI is enabled by default.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>GSSAPI</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.jaas.config"></a><a id="brokerconfigs_sasl.jaas.config" href="#brokerconfigs_sasl.jaas.config">sasl.jaas.config</a></h4>
<p>JAAS login context parameters for SASL connections in the format used by JAAS configuration files. JAAS configuration file format is described <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html">here</a>. The format for the value is: <code>loginModuleClass controlFlag (optionName=optionValue)*;</code>. For brokers, the config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.jaas.config=com.example.ScramLoginModule required;</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.kinit.cmd"></a><a id="brokerconfigs_sasl.kerberos.kinit.cmd" href="#brokerconfigs_sasl.kerberos.kinit.cmd">sasl.kerberos.kinit.cmd</a></h4>
<p>Kerberos kinit command path.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>/usr/bin/kinit</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.min.time.before.relogin"></a><a id="brokerconfigs_sasl.kerberos.min.time.before.relogin" href="#brokerconfigs_sasl.kerberos.min.time.before.relogin">sasl.kerberos.min.time.before.relogin</a></h4>
<p>Login thread sleep time between refresh attempts.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>60000</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.principal.to.local.rules"></a><a id="brokerconfigs_sasl.kerberos.principal.to.local.rules" href="#brokerconfigs_sasl.kerberos.principal.to.local.rules">sasl.kerberos.principal.to.local.rules</a></h4>
<p>A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form <code>{username}/{hostname}@{REALM}</code> are mapped to <code>{username}</code>. For more details on the format please see <a href="#security_authz"> security authorization and acls</a>. Note that this configuration is ignored if an extension of <code>KafkaPrincipalBuilder</code> is provided by the <code>principal.builder.class</code> configuration.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>DEFAULT</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.service.name"></a><a id="brokerconfigs_sasl.kerberos.service.name" href="#brokerconfigs_sasl.kerberos.service.name">sasl.kerberos.service.name</a></h4>
<p>The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.ticket.renew.jitter"></a><a id="brokerconfigs_sasl.kerberos.ticket.renew.jitter" href="#brokerconfigs_sasl.kerberos.ticket.renew.jitter">sasl.kerberos.ticket.renew.jitter</a></h4>
<p>Percentage of random jitter added to the renewal time.</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.05</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.kerberos.ticket.renew.window.factor"></a><a id="brokerconfigs_sasl.kerberos.ticket.renew.window.factor" href="#brokerconfigs_sasl.kerberos.ticket.renew.window.factor">sasl.kerberos.ticket.renew.window.factor</a></h4>
<p>Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.8</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.callback.handler.class"></a><a id="brokerconfigs_sasl.login.callback.handler.class" href="#brokerconfigs_sasl.login.callback.handler.class">sasl.login.callback.handler.class</a></h4>
<p>The fully qualified name of a SASL login callback handler class that implements the AuthenticateCallbackHandler interface. For brokers, login callback handler config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.callback.handler.class=com.example.CustomScramLoginCallbackHandler</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.class"></a><a id="brokerconfigs_sasl.login.class" href="#brokerconfigs_sasl.login.class">sasl.login.class</a></h4>
<p>The fully qualified name of a class that implements the Login interface. For brokers, login config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.class=com.example.CustomScramLogin</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.refresh.buffer.seconds"></a><a id="brokerconfigs_sasl.login.refresh.buffer.seconds" href="#brokerconfigs_sasl.login.refresh.buffer.seconds">sasl.login.refresh.buffer.seconds</a></h4>
<p>The amount of buffer time before credential expiration to maintain when refreshing a credential, in seconds. If a refresh would otherwise occur closer to expiration than the number of buffer seconds then the refresh will be moved up to maintain as much of the buffer time as possible. Legal values are between 0 and 3600 (1 hour); a default value of  300 (5 minutes) is used if no value is specified. This value and sasl.login.refresh.min.period.seconds are both ignored if their sum exceeds the remaining lifetime of a credential. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>300</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.refresh.min.period.seconds"></a><a id="brokerconfigs_sasl.login.refresh.min.period.seconds" href="#brokerconfigs_sasl.login.refresh.min.period.seconds">sasl.login.refresh.min.period.seconds</a></h4>
<p>The desired minimum time for the login refresh thread to wait before refreshing a credential, in seconds. Legal values are between 0 and 900 (15 minutes); a default value of 60 (1 minute) is used if no value is specified.  This value and  sasl.login.refresh.buffer.seconds are both ignored if their sum exceeds the remaining lifetime of a credential. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>short</td></tr>
<tr><th>Default:</th><td>60</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.refresh.window.factor"></a><a id="brokerconfigs_sasl.login.refresh.window.factor" href="#brokerconfigs_sasl.login.refresh.window.factor">sasl.login.refresh.window.factor</a></h4>
<p>Login refresh thread will sleep until the specified window factor relative to the credential's lifetime has been reached, at which time it will try to refresh the credential. Legal values are between 0.5 (50%) and 1.0 (100%) inclusive; a default value of 0.8 (80%) is used if no value is specified. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.8</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.refresh.window.jitter"></a><a id="brokerconfigs_sasl.login.refresh.window.jitter" href="#brokerconfigs_sasl.login.refresh.window.jitter">sasl.login.refresh.window.jitter</a></h4>
<p>The maximum amount of random jitter relative to the credential's lifetime that is added to the login refresh thread's sleep time. Legal values are between 0 and 0.25 (25%) inclusive; a default value of 0.05 (5%) is used if no value is specified. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>double</td></tr>
<tr><th>Default:</th><td>0.05</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.mechanism.inter.broker.protocol"></a><a id="brokerconfigs_sasl.mechanism.inter.broker.protocol" href="#brokerconfigs_sasl.mechanism.inter.broker.protocol">sasl.mechanism.inter.broker.protocol</a></h4>
<p>SASL mechanism used for inter-broker communication. Default is GSSAPI.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>GSSAPI</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.algorithm"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.algorithm" href="#brokerconfigs_sasl.oauthbearer.assertion.algorithm">sasl.oauthbearer.assertion.algorithm</a></h4>
<p><p>The algorithm the Apache Kafka client should use to sign the assertion sent to the identity provider. It is also used as the value of the OAuth <code>alg</code> (Algorithm) header in the JWT assertion.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>RS256</td></tr>
<tr><th>Valid Values:</th><td>(case insensitive) [ES256, RS256]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.aud"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.aud" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.aud">sasl.oauthbearer.assertion.claim.aud</a></h4>
<p><p>The JWT <code>aud</code> (Audience) claim which will be included in the  client JWT assertion created locally.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.iss"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.iss" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.iss">sasl.oauthbearer.assertion.claim.iss</a></h4>
<p><p>The value to be used as the <code>iss</code> (Issuer) claim which will be included in the client JWT assertion created locally.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.jti.include"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.jti.include" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.jti.include">sasl.oauthbearer.assertion.claim.jti.include</a></h4>
<p><p>Flag that determines if the JWT assertion should generate a unique ID for the JWT and include it in the <code>jti</code> (JWT ID) claim.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.sub"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.sub" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.sub">sasl.oauthbearer.assertion.claim.sub</a></h4>
<p><p>The value to be used as the <code>sub</code> (Subject) claim which will be included in the client JWT assertion created locally.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.file"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.file" href="#brokerconfigs_sasl.oauthbearer.assertion.file">sasl.oauthbearer.assertion.file</a></h4>
<p><p>File that contains a <em>pre-generated</em> JWT assertion.</p><p>The underlying implementation caches the file contents to avoid the performance hit of loading the file on each access. The caching mechanism will detect whenthe file changes to allow for the file to be reloaded on modifications. This allows for &quot;live&quot; assertion rotation without restarting the Kafka client.</p><p>The file contains the assertion in the serialized, three part JWT format:</p><ol><li>The <em>header</em> section is a base 64-encoded JWT header that contains values like <code>alg</code> (Algorithm), <code>typ</code> (Type, always the literal value <code>JWT</code>), etc.</li><li>The <em>payload</em> section includes the base 64-encoded set of JWT claims, such as <code>aud</code> (Audience), <code>iss</code> (Issuer), <code>sub</code> (Subject), etc.</li><li>The <em>signature</em> section is the concatenated <em>header</em> and <em>payload</em> sections that was signed using a private key</li></ol><p>See <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a> for more details on the JWT and JWS formats.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, all other <code>sasl.oauthbearer.assertion.</code>* configurations are ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.private.key.file"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.private.key.file" href="#brokerconfigs_sasl.oauthbearer.assertion.private.key.file">sasl.oauthbearer.assertion.private.key.file</a></h4>
<p><p>File that contains a private key in the standard PEM format which is used to sign the JWT assertion sent to the identity provider.</p><p>The underlying implementation caches the file contents to avoid the performance hit of loading the file on each access. The caching mechanism will detect when the file changes to allow for the file to be reloaded on modifications. This allows for &quot;live&quot; private key rotation without restarting the Kafka client.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.private.key.passphrase"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.private.key.passphrase" href="#brokerconfigs_sasl.oauthbearer.assertion.private.key.passphrase">sasl.oauthbearer.assertion.private.key.passphrase</a></h4>
<p><p>The optional passphrase to decrypt the private key file specified by <code>sasl.oauthbearer.assertion.private.key.file</code>.</p><p><em>Note</em>: If the file referred to by <code>sasl.oauthbearer.assertion.private.key.file</code> is modified on the file system at runtime and it was created with a <em>different</em> passphrase than it was previously, the client will not be able to access the private key file because the passphrase is now out of date. For that reason, when using private key passphrases, either use the same passphrase each time, or&mdash;for improved security&mdash;restart the Kafka client using the new passphrase configuration.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.template.file"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.template.file" href="#brokerconfigs_sasl.oauthbearer.assertion.template.file">sasl.oauthbearer.assertion.template.file</a></h4>
<p><p>This optional configuration specifies the file containing the JWT headers and/or payload claims to be used when creating the JWT assertion.</p><p>Not all identity providers require the same set of claims; some may require a given claim while others may prohibit it. In order to provide the most flexibility, this configuration allows the user to provide the static header values and claims that are to be included in the JWT.</p><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.client.credentials.client.id"></a><a id="brokerconfigs_sasl.oauthbearer.client.credentials.client.id" href="#brokerconfigs_sasl.oauthbearer.client.credentials.client.id">sasl.oauthbearer.client.credentials.client.id</a></h4>
<p><p>The ID (defined in/by the OAuth identity provider) to identify the client requesting the token.</p><p>The client ID was previously stored as part of the <code>sasl.jaas.config</code> configuration with the key <code>clientId</code>. For backward compatibility, the <code>clientId</code> JAAS option can still be used, but it is deprecated and will be removed in a future version.</p><p>Order of precedence:</p><ul><li><code>sasl.oauthbearer.client.credentials.client.id</code> from configuration</li><li><code>clientId</code> from JAAS</li></ul></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.client.credentials.client.secret"></a><a id="brokerconfigs_sasl.oauthbearer.client.credentials.client.secret" href="#brokerconfigs_sasl.oauthbearer.client.credentials.client.secret">sasl.oauthbearer.client.credentials.client.secret</a></h4>
<p><p>The secret (defined by either the user or preassigned, depending on the identity provider) of the client requesting the token.</p><p>The client secret was previously stored as part of the <code>sasl.jaas.config</code> configuration with the key <code>clientSecret</code>. For backward compatibility, the <code>clientSecret</code> JAAS option can still be used, but it is deprecated and will be removed in a future version.</p><p>Order of precedence:</p><ul><li><code>sasl.oauthbearer.client.credentials.client.secret</code> from configuration</li><li><code>clientSecret</code> from JAAS</li></ul></p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwks.endpoint.url"></a><a id="brokerconfigs_sasl.oauthbearer.jwks.endpoint.url" href="#brokerconfigs_sasl.oauthbearer.jwks.endpoint.url">sasl.oauthbearer.jwks.endpoint.url</a></h4>
<p>The OAuth/OIDC provider URL from which the provider's <a href="https://datatracker.ietf.org/doc/html/rfc7517#section-5">JWKS (JSON Web Key Set)</a> can be retrieved. The URL can be HTTP(S)-based or file-based. If the URL is HTTP(S)-based, the JWKS data will be retrieved from the OAuth/OIDC provider via the configured URL on broker startup. All then-current keys will be cached on the broker for incoming requests. If an authentication request is received for a JWT that includes a "kid" header claim value that isn't yet in the cache, the JWKS endpoint will be queried again on demand. However, the broker polls the URL every sasl.oauthbearer.jwks.endpoint.refresh.ms milliseconds to refresh the cache with any forthcoming keys before any JWT requests that include them are received. If the URL is file-based, the broker will load the JWKS file from a configured location on startup. In the event that the JWT includes a "kid" header value that isn't in the JWKS file, the broker will reject the JWT and authentication will fail.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwt.retriever.class"></a><a id="brokerconfigs_sasl.oauthbearer.jwt.retriever.class" href="#brokerconfigs_sasl.oauthbearer.jwt.retriever.class">sasl.oauthbearer.jwt.retriever.class</a></h4>
<p><p>The fully-qualified class name of a <code>JwtRetriever</code> implementation used to request tokens from the identity provider.</p><p>The default configuration value represents a class that maintains backward compatibility with previous versions of Apache Kafka. The default implementation uses the configuration to determine which concrete implementation to create.<p>Other implementations that are provided include:</p><ul><li><code>org.apache.kafka.common.security.oauthbearer.ClientCredentialsJwtRetriever</code></li><li><code>org.apache.kafka.common.security.oauthbearer.DefaultJwtRetriever</code></li><li><code>org.apache.kafka.common.security.oauthbearer.FileJwtRetriever</code></li><li><code>org.apache.kafka.common.security.oauthbearer.JwtBearerJwtRetriever</code></li></ul></p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>org.apache.kafka.common.security.oauthbearer.DefaultJwtRetriever</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwt.validator.class"></a><a id="brokerconfigs_sasl.oauthbearer.jwt.validator.class" href="#brokerconfigs_sasl.oauthbearer.jwt.validator.class">sasl.oauthbearer.jwt.validator.class</a></h4>
<p><p>The fully-qualified class name of a <code>JwtValidator</code> implementation used to validate the JWT from the identity provider.</p><p>The default validator (<code>org.apache.kafka.common.security.oauthbearer.DefaultJwtValidator</code>) maintains backward compatibility with previous versions of Apache Kafka. The default validator uses configuration to determine which concrete implementation to create.<p>The built-in <code>JwtValidator</code> implementations are:</p><ul><li><code>org.apache.kafka.common.security.oauthbearer.BrokerJwtValidator</code></li><li><code>org.apache.kafka.common.security.oauthbearer.ClientJwtValidator</code></li><li><code>org.apache.kafka.common.security.oauthbearer.DefaultJwtValidator</code></li></ul></p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>org.apache.kafka.common.security.oauthbearer.DefaultJwtValidator</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.scope"></a><a id="brokerconfigs_sasl.oauthbearer.scope" href="#brokerconfigs_sasl.oauthbearer.scope">sasl.oauthbearer.scope</a></h4>
<p><p>This is the level of access a client application is granted to a resource or API which is included in the token request. If provided, it should match one or more scopes configured in the identity provider.</p><p>The scope was previously stored as part of the <code>sasl.jaas.config</code> configuration with the key <code>scope</code>. For backward compatibility, the <code>scope</code> JAAS option can still be used, but it is deprecated and will be removed in a future version.</p><p>Order of precedence:</p><ul><li><code>sasl.oauthbearer.scope</code> from configuration</li><li><code>scope</code> from JAAS</li></ul></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.token.endpoint.url"></a><a id="brokerconfigs_sasl.oauthbearer.token.endpoint.url" href="#brokerconfigs_sasl.oauthbearer.token.endpoint.url">sasl.oauthbearer.token.endpoint.url</a></h4>
<p>The URL for the OAuth/OIDC identity provider. If the URL is HTTP(S)-based, it is the issuer's token endpoint URL to which requests will be made to login based on the configuration in <code>sasl.oauthbearer.jwt.retriever.class</code>. If the URL is file-based, it specifies a file containing an access token (in JWT serialized form) issued by the OAuth/OIDC identity provider to use for authorization.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.server.callback.handler.class"></a><a id="brokerconfigs_sasl.server.callback.handler.class" href="#brokerconfigs_sasl.server.callback.handler.class">sasl.server.callback.handler.class</a></h4>
<p>The fully qualified name of a SASL server callback handler class that implements the AuthenticateCallbackHandler interface. Server callback handlers must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.plain.sasl.server.callback.handler.class=com.example.CustomPlainCallbackHandler.</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.server.max.receive.size"></a><a id="brokerconfigs_sasl.server.max.receive.size" href="#brokerconfigs_sasl.server.max.receive.size">sasl.server.max.receive.size</a></h4>
<p>The maximum receive size allowed before and during initial SASL authentication. Default receive size is 512KB. GSSAPI limits requests to 64K, but we allow upto 512KB by default for custom SASL mechanisms. In practice, PLAIN, SCRAM and OAUTH mechanisms can use much smaller limits.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>524288</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="security.inter.broker.protocol"></a><a id="brokerconfigs_security.inter.broker.protocol" href="#brokerconfigs_security.inter.broker.protocol">security.inter.broker.protocol</a></h4>
<p>Security protocol used to communicate between brokers. It is an error to set this and inter.broker.listener.name properties at the same time.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>PLAINTEXT</td></tr>
<tr><th>Valid Values:</th><td>[PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.append.linger.ms"></a><a id="brokerconfigs_share.coordinator.append.linger.ms" href="#brokerconfigs_share.coordinator.append.linger.ms">share.coordinator.append.linger.ms</a></h4>
<p>The duration in milliseconds that the share coordinator will wait for writes to accumulate before flushing them to disk.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>5</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.snapshot.update.records.per.snapshot"></a><a id="brokerconfigs_share.coordinator.snapshot.update.records.per.snapshot" href="#brokerconfigs_share.coordinator.snapshot.update.records.per.snapshot">share.coordinator.snapshot.update.records.per.snapshot</a></h4>
<p>The number of update records the share coordinator writes between snapshot records.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>500</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.coordinator.threads"></a><a id="brokerconfigs_share.coordinator.threads" href="#brokerconfigs_share.coordinator.threads">share.coordinator.threads</a></h4>
<p>The number of threads used by the share coordinator.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="share.fetch.purgatory.purge.interval.requests"></a><a id="brokerconfigs_share.fetch.purgatory.purge.interval.requests" href="#brokerconfigs_share.fetch.purgatory.purge.interval.requests">share.fetch.purgatory.purge.interval.requests</a></h4>
<p>The purge interval (in number of requests) of the share fetch request purgatory</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1000</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.connection.setup.timeout.max.ms"></a><a id="brokerconfigs_socket.connection.setup.timeout.max.ms" href="#brokerconfigs_socket.connection.setup.timeout.max.ms">socket.connection.setup.timeout.max.ms</a></h4>
<p>The maximum amount of time the client will wait for the socket connection to be established. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the timeout resulting in a random range between 20% below and 20% above the computed value.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.connection.setup.timeout.ms"></a><a id="brokerconfigs_socket.connection.setup.timeout.ms" href="#brokerconfigs_socket.connection.setup.timeout.ms">socket.connection.setup.timeout.ms</a></h4>
<p>The amount of time the client will wait for the socket connection to be established. If the connection is not built before the timeout elapses, clients will close the socket channel. This value is the initial backoff value and will increase exponentially for each consecutive connection failure, up to the <code>socket.connection.setup.timeout.max.ms</code> value.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>10000 (10 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="socket.listen.backlog.size"></a><a id="brokerconfigs_socket.listen.backlog.size" href="#brokerconfigs_socket.listen.backlog.size">socket.listen.backlog.size</a></h4>
<p>The maximum number of pending connections on the socket. In Linux, you may also need to configure <code>somaxconn</code> and <code>tcp_max_syn_backlog</code> kernel parameters accordingly to make the configuration takes effect.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>50</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.cipher.suites"></a><a id="brokerconfigs_ssl.cipher.suites" href="#brokerconfigs_ssl.cipher.suites">ssl.cipher.suites</a></h4>
<p>A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. By default all the available cipher suites are supported.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.client.auth"></a><a id="brokerconfigs_ssl.client.auth" href="#brokerconfigs_ssl.client.auth">ssl.client.auth</a></h4>
<p>Configures kafka broker to request client authentication. The following settings are common:  <ul> <li><code>ssl.client.auth=required</code> If set to required client authentication is required. <li><code>ssl.client.auth=requested</code> This means client authentication is optional. unlike required, if this option is set client can choose not to provide authentication information about itself <li><code>ssl.client.auth=none</code> This means client authentication is not needed.</ul></p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>none</td></tr>
<tr><th>Valid Values:</th><td>[required, requested, none]</td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.enabled.protocols"></a><a id="brokerconfigs_ssl.enabled.protocols" href="#brokerconfigs_ssl.enabled.protocols">ssl.enabled.protocols</a></h4>
<p>The list of protocols enabled for SSL connections. The default is 'TLSv1.2,TLSv1.3'. This means that clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most use cases. Also see the config documentation for `ssl.protocol` to understand how it can impact the TLS version negotiation behavior.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>TLSv1.2,TLSv1.3</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.key.password"></a><a id="brokerconfigs_ssl.key.password" href="#brokerconfigs_ssl.key.password">ssl.key.password</a></h4>
<p>The password of the private key in the key store file or the PEM key specified in 'ssl.keystore.key'.</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keymanager.algorithm"></a><a id="brokerconfigs_ssl.keymanager.algorithm" href="#brokerconfigs_ssl.keymanager.algorithm">ssl.keymanager.algorithm</a></h4>
<p>The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>SunX509</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keystore.certificate.chain"></a><a id="brokerconfigs_ssl.keystore.certificate.chain" href="#brokerconfigs_ssl.keystore.certificate.chain">ssl.keystore.certificate.chain</a></h4>
<p>Certificate chain in the format specified by 'ssl.keystore.type'. Default SSL engine factory supports only PEM format with a list of X.509 certificates</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keystore.key"></a><a id="brokerconfigs_ssl.keystore.key" href="#brokerconfigs_ssl.keystore.key">ssl.keystore.key</a></h4>
<p>Private key in the format specified by 'ssl.keystore.type'. Default SSL engine factory supports only PEM format with PKCS#8 keys. If the key is encrypted, key password must be specified using 'ssl.key.password'</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keystore.location"></a><a id="brokerconfigs_ssl.keystore.location" href="#brokerconfigs_ssl.keystore.location">ssl.keystore.location</a></h4>
<p>The location of the key store file. This is optional for client and can be used for two-way authentication for client.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keystore.password"></a><a id="brokerconfigs_ssl.keystore.password" href="#brokerconfigs_ssl.keystore.password">ssl.keystore.password</a></h4>
<p>The store password for the key store file. This is optional for client and only needed if 'ssl.keystore.location' is configured. Key store password is not supported for PEM format.</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.keystore.type"></a><a id="brokerconfigs_ssl.keystore.type" href="#brokerconfigs_ssl.keystore.type">ssl.keystore.type</a></h4>
<p>The file format of the key store file. This is optional for client. The values currently supported by the default `ssl.engine.factory.class` are [JKS, PKCS12, PEM].</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>JKS</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.protocol"></a><a id="brokerconfigs_ssl.protocol" href="#brokerconfigs_ssl.protocol">ssl.protocol</a></h4>
<p>The SSL protocol used to generate the SSLContext. The default is 'TLSv1.3', which should be fine for most use cases. A typical alternative to the default is 'TLSv1.2'. Allowed values for this config are dependent on the JVM. Clients using the defaults for this config and 'ssl.enabled.protocols' will downgrade to 'TLSv1.2' if the server does not support 'TLSv1.3'. If this config is set to 'TLSv1.2', however, clients will not use 'TLSv1.3' even if it is one of the values in `ssl.enabled.protocols` and the server only supports 'TLSv1.3'.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>TLSv1.3</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.provider"></a><a id="brokerconfigs_ssl.provider" href="#brokerconfigs_ssl.provider">ssl.provider</a></h4>
<p>The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.trustmanager.algorithm"></a><a id="brokerconfigs_ssl.trustmanager.algorithm" href="#brokerconfigs_ssl.trustmanager.algorithm">ssl.trustmanager.algorithm</a></h4>
<p>The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>PKIX</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.truststore.certificates"></a><a id="brokerconfigs_ssl.truststore.certificates" href="#brokerconfigs_ssl.truststore.certificates">ssl.truststore.certificates</a></h4>
<p>Trusted certificates in the format specified by 'ssl.truststore.type'. Default SSL engine factory supports only PEM format with X.509 certificates.</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.truststore.location"></a><a id="brokerconfigs_ssl.truststore.location" href="#brokerconfigs_ssl.truststore.location">ssl.truststore.location</a></h4>
<p>The location of the trust store file.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.truststore.password"></a><a id="brokerconfigs_ssl.truststore.password" href="#brokerconfigs_ssl.truststore.password">ssl.truststore.password</a></h4>
<p>The password for the trust store file. If a password is not set, trust store file configured will still be used, but integrity checking is disabled. Trust store password is not supported for PEM format.</p>
<table><tbody>
<tr><th>Type:</th><td>password</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.truststore.type"></a><a id="brokerconfigs_ssl.truststore.type" href="#brokerconfigs_ssl.truststore.type">ssl.truststore.type</a></h4>
<p>The file format of the trust store file. The values currently supported by the default `ssl.engine.factory.class` are [JKS, PKCS12, PEM].</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>JKS</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>medium</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="alter.config.policy.class.name"></a><a id="brokerconfigs_alter.config.policy.class.name" href="#brokerconfigs_alter.config.policy.class.name">alter.config.policy.class.name</a></h4>
<p>The alter configs policy class that should be used for validation. The class should implement the <code>org.apache.kafka.server.policy.AlterConfigPolicy</code> interface. <p>Note: This policy runs on the controller instead of the broker.</p></p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="alter.log.dirs.replication.quota.window.num"></a><a id="brokerconfigs_alter.log.dirs.replication.quota.window.num" href="#brokerconfigs_alter.log.dirs.replication.quota.window.num">alter.log.dirs.replication.quota.window.num</a></h4>
<p>The number of samples to retain in memory for alter log dirs replication quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="alter.log.dirs.replication.quota.window.size.seconds"></a><a id="brokerconfigs_alter.log.dirs.replication.quota.window.size.seconds" href="#brokerconfigs_alter.log.dirs.replication.quota.window.size.seconds">alter.log.dirs.replication.quota.window.size.seconds</a></h4>
<p>The time span of each sample for alter log dirs replication quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="authorizer.class.name"></a><a id="brokerconfigs_authorizer.class.name" href="#brokerconfigs_authorizer.class.name">authorizer.class.name</a></h4>
<p>The fully qualified name of a class that implements <code>org.apache.kafka.server.authorizer.Authorizer</code> interface, which is used by the broker for authorization.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td>non-null string</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="client.quota.callback.class"></a><a id="brokerconfigs_client.quota.callback.class" href="#brokerconfigs_client.quota.callback.class">client.quota.callback.class</a></h4>
<p>The fully qualified name of a class that implements the ClientQuotaCallback interface, which is used to determine quota limits applied to client requests. By default, the &lt;user&gt; and &lt;client-id&gt quotas that are stored and applied. For any given request, the most specific quota that matches the user principal of the session and the client-id of the request is applied.</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="connection.failed.authentication.delay.ms"></a><a id="brokerconfigs_connection.failed.authentication.delay.ms" href="#brokerconfigs_connection.failed.authentication.delay.ms">connection.failed.authentication.delay.ms</a></h4>
<p>Connection close delay on failed authentication: this is the time (in milliseconds) by which connection close will be delayed on authentication failure. This must be configured to be less than connections.max.idle.ms to prevent connection timeout.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>100</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quorum.retry.backoff.ms"></a><a id="brokerconfigs_controller.quorum.retry.backoff.ms" href="#brokerconfigs_controller.quorum.retry.backoff.ms">controller.quorum.retry.backoff.ms</a></h4>
<p>The amount of time to wait before attempting to retry a failed request to a given topic partition. This avoids repeatedly sending requests in a tight loop under some failure scenarios. This value is the initial backoff value and will increase exponentially for each failed request, up to the <code>retry.backoff.max.ms</code> value.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>20</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quota.window.num"></a><a id="brokerconfigs_controller.quota.window.num" href="#brokerconfigs_controller.quota.window.num">controller.quota.window.num</a></h4>
<p>The number of samples to retain in memory for controller mutation quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="controller.quota.window.size.seconds"></a><a id="brokerconfigs_controller.quota.window.size.seconds" href="#brokerconfigs_controller.quota.window.size.seconds">controller.quota.window.size.seconds</a></h4>
<p>The time span of each sample for controller mutations quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="create.topic.policy.class.name"></a><a id="brokerconfigs_create.topic.policy.class.name" href="#brokerconfigs_create.topic.policy.class.name">create.topic.policy.class.name</a></h4>
<p>The create topic policy class that should be used for validation. The class should implement the <code>org.apache.kafka.server.policy.CreateTopicPolicy</code> interface. <p>Note: This policy runs on the controller instead of the broker.</p></p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="delegation.token.expiry.check.interval.ms"></a><a id="brokerconfigs_delegation.token.expiry.check.interval.ms" href="#brokerconfigs_delegation.token.expiry.check.interval.ms">delegation.token.expiry.check.interval.ms</a></h4>
<p>Scan interval to remove expired delegation tokens.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>3600000 (1 hour)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="kafka.metrics.polling.interval.secs"></a><a id="brokerconfigs_kafka.metrics.polling.interval.secs" href="#brokerconfigs_kafka.metrics.polling.interval.secs">kafka.metrics.polling.interval.secs</a></h4>
<p>The metrics polling interval (in seconds) which can be used in kafka.metrics.reporters implementations.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="kafka.metrics.reporters"></a><a id="brokerconfigs_kafka.metrics.reporters" href="#brokerconfigs_kafka.metrics.reporters">kafka.metrics.reporters</a></h4>
<p>A list of classes to use as Yammer metrics custom reporters. The reporters should implement <code>kafka.metrics.KafkaMetricsReporter</code> trait. If a client wants to expose JMX operations on a custom reporter, the custom reporter needs to additionally implement an MBean trait that extends <code>kafka.metrics.KafkaMetricsReporterMBean</code> trait so that the registered MBean is compliant with the standard MBean convention.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>""</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="listener.security.protocol.map"></a><a id="brokerconfigs_listener.security.protocol.map" href="#brokerconfigs_listener.security.protocol.map">listener.security.protocol.map</a></h4>
<p>Map between listener names and security protocols. This must be defined for the same security protocol to be usable in more than one port or IP. For example, internal and external traffic can be separated even if SSL is required for both. Concretely, the user could define listeners with names INTERNAL and EXTERNAL and this property as: <code>INTERNAL:SSL,EXTERNAL:SSL</code>. As shown, key and value are separated by a colon and map entries are separated by commas. Each listener name should only appear once in the map. Different security (SSL and SASL) settings can be configured for each listener by adding a normalised prefix (the listener name is lowercased) to the config name. For example, to set a different keystore for the INTERNAL listener, a config with name <code>listener.name.internal.ssl.keystore.location</code> would be set. If the config for the listener name is not set, the config will fallback to the generic config (i.e. <code>ssl.keystore.location</code>). Note that in KRaft a default mapping from the listener names defined by <code>controller.listener.names</code> to PLAINTEXT is assumed if no explicit mapping is provided and no other security protocol is in use.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>SASL_SSL:SASL_SSL,PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="log.dir.failure.timeout.ms"></a><a id="brokerconfigs_log.dir.failure.timeout.ms" href="#brokerconfigs_log.dir.failure.timeout.ms">log.dir.failure.timeout.ms</a></h4>
<p>If the broker is unable to successfully communicate to the controller that some log directory has failed for longer than this time, the broker will fail and shut down.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metadata.max.idle.interval.ms"></a><a id="brokerconfigs_metadata.max.idle.interval.ms" href="#brokerconfigs_metadata.max.idle.interval.ms">metadata.max.idle.interval.ms</a></h4>
<p>This configuration controls how often the active controller should write no-op records to the metadata partition. If the value is 0, no-op records are not appended to the metadata partition. The default value is 500</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>500</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metric.reporters"></a><a id="brokerconfigs_metric.reporters" href="#brokerconfigs_metric.reporters">metric.reporters</a></h4>
<p>A list of classes to use as metrics reporters. Implementing the <code>org.apache.kafka.common.metrics.MetricsReporter</code> interface allows plugging in classes that will be notified of new metric creation. When custom reporters are set and <code>org.apache.kafka.common.metrics.JmxReporter</code> is needed, it has to be explicitly added to the list.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>org.apache.kafka.common.metrics.JmxReporter</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metrics.num.samples"></a><a id="brokerconfigs_metrics.num.samples" href="#brokerconfigs_metrics.num.samples">metrics.num.samples</a></h4>
<p>The number of samples maintained to compute metrics.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>2</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metrics.recording.level"></a><a id="brokerconfigs_metrics.recording.level" href="#brokerconfigs_metrics.recording.level">metrics.recording.level</a></h4>
<p>The highest recording level for metrics. It has three levels for recording metrics - info, debug, and trace.<br> <br>INFO level records only essential metrics necessary for monitoring system performance and health. It collects vital data without gathering too much detail, making it suitable for production environments where minimal overhead is desired.<br><br>DEBUG level records most metrics, providing more detailed information about the system's operation. It's useful for development and testing environments where you need deeper insights to debug and fine-tune the application.<br><br>TRACE level records all possible metrics, capturing every detail about the system's performance and operation. It's best for controlled environments where in-depth analysis is required, though it can introduce significant overhead.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>INFO</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="metrics.sample.window.ms"></a><a id="brokerconfigs_metrics.sample.window.ms" href="#brokerconfigs_metrics.sample.window.ms">metrics.sample.window.ms</a></h4>
<p>The window of time a metrics sample is computed over.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="producer.id.expiration.ms"></a><a id="brokerconfigs_producer.id.expiration.ms" href="#brokerconfigs_producer.id.expiration.ms">producer.id.expiration.ms</a></h4>
<p>The time in ms that a topic partition leader will wait before expiring producer IDs. Producer IDs will not expire while a transaction associated to them is still ongoing. Note that producer IDs may expire sooner if the last write from the producer ID is deleted due to the topic's retention settings. Setting this value the same or higher than <code>delivery.timeout.ms</code> can help prevent expiration during retries and protect against message duplication, but the default should be reasonable for most use cases.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>86400000 (1 day)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="quota.window.num"></a><a id="brokerconfigs_quota.window.num" href="#brokerconfigs_quota.window.num">quota.window.num</a></h4>
<p>The number of samples to retain in memory for client quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="quota.window.size.seconds"></a><a id="brokerconfigs_quota.window.size.seconds" href="#brokerconfigs_quota.window.size.seconds">quota.window.size.seconds</a></h4>
<p>The time span of each sample for client quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.index.file.cache.total.size.bytes"></a><a id="brokerconfigs_remote.log.index.file.cache.total.size.bytes" href="#brokerconfigs_remote.log.index.file.cache.total.size.bytes">remote.log.index.file.cache.total.size.bytes</a></h4>
<p>The total size of the space allocated to store index files fetched from remote storage in the local storage.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>1073741824 (1 gibibyte)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.manager.task.interval.ms"></a><a id="brokerconfigs_remote.log.manager.task.interval.ms" href="#brokerconfigs_remote.log.manager.task.interval.ms">remote.log.manager.task.interval.ms</a></h4>
<p>Interval at which remote log manager runs the scheduled tasks like copy segments, and clean up remote log segments.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>30000 (30 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="remote.log.metadata.custom.metadata.max.bytes"></a><a id="brokerconfigs_remote.log.metadata.custom.metadata.max.bytes" href="#brokerconfigs_remote.log.metadata.custom.metadata.max.bytes">remote.log.metadata.custom.metadata.max.bytes</a></h4>
<p>The maximum size of custom metadata in bytes that the broker should accept from a remote storage plugin. If custom  metadata exceeds this limit, the updated segment metadata will not be stored, the copied data will be attempted to delete, and the remote copying task for this topic-partition will stop with an error.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>128</td></tr>
<tr><th>Valid Values:</th><td>[0,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replication.quota.window.num"></a><a id="brokerconfigs_replication.quota.window.num" href="#brokerconfigs_replication.quota.window.num">replication.quota.window.num</a></h4>
<p>The number of samples to retain in memory for replication quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>11</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="replication.quota.window.size.seconds"></a><a id="brokerconfigs_replication.quota.window.size.seconds" href="#brokerconfigs_replication.quota.window.size.seconds">replication.quota.window.size.seconds</a></h4>
<p>The time span of each sample for replication quotas</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.connect.timeout.ms"></a><a id="brokerconfigs_sasl.login.connect.timeout.ms" href="#brokerconfigs_sasl.login.connect.timeout.ms">sasl.login.connect.timeout.ms</a></h4>
<p>The (optional) value in milliseconds for the external authentication provider connection timeout. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.read.timeout.ms"></a><a id="brokerconfigs_sasl.login.read.timeout.ms" href="#brokerconfigs_sasl.login.read.timeout.ms">sasl.login.read.timeout.ms</a></h4>
<p>The (optional) value in milliseconds for the external authentication provider read timeout. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.retry.backoff.max.ms"></a><a id="brokerconfigs_sasl.login.retry.backoff.max.ms" href="#brokerconfigs_sasl.login.retry.backoff.max.ms">sasl.login.retry.backoff.max.ms</a></h4>
<p>The (optional) value in milliseconds for the maximum wait between login attempts to the external authentication provider. Login uses an exponential backoff algorithm with an initial wait based on the sasl.login.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.login.retry.backoff.max.ms setting. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>10000 (10 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.login.retry.backoff.ms"></a><a id="brokerconfigs_sasl.login.retry.backoff.ms" href="#brokerconfigs_sasl.login.retry.backoff.ms">sasl.login.retry.backoff.ms</a></h4>
<p>The (optional) value in milliseconds for the initial wait between login attempts to the external authentication provider. Login uses an exponential backoff algorithm with an initial wait based on the sasl.login.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.login.retry.backoff.max.ms setting. Currently applies only to OAUTHBEARER.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>100</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.exp.seconds"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.exp.seconds" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.exp.seconds">sasl.oauthbearer.assertion.claim.exp.seconds</a></h4>
<p><p>The number of seconds <em>in the future</em> for which the JWT is valid. The value is used to determine the JWT <code>exp</code> (Expiration) claim based on the current system time when the JWT is created.</p><p>The formula to generate the <code>exp</code> claim is very simple:</p><pre>Let:<br><br>  x = the current timestamp in seconds, on client<br>  y = the value of this configuration<br><br>Then:<br><br>  exp = x + y<br></pre><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>300</td></tr>
<tr><th>Valid Values:</th><td>[0,...,86400]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.assertion.claim.nbf.seconds"></a><a id="brokerconfigs_sasl.oauthbearer.assertion.claim.nbf.seconds" href="#brokerconfigs_sasl.oauthbearer.assertion.claim.nbf.seconds">sasl.oauthbearer.assertion.claim.nbf.seconds</a></h4>
<p><p>The number of seconds <em>in the past</em> from which the JWT is valid. The value is used to determine the JWT <code>nbf</code> (Not Before) claim based on the current system time when the JWT is created.</p><p>The formula to generate the <code>nbf</code> claim is very simple:</p><pre>Let:<br><br>  x = the current timestamp in seconds, on client<br>  y = the value of this configuration<br><br>Then:<br><br>  nbf = x - y<br></pre><p><em>Note</em>: If a value for <code>sasl.oauthbearer.assertion.file</code> is provided, this configuration will be ignored.</p></p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>60</td></tr>
<tr><th>Valid Values:</th><td>[0,...,3600]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.clock.skew.seconds"></a><a id="brokerconfigs_sasl.oauthbearer.clock.skew.seconds" href="#brokerconfigs_sasl.oauthbearer.clock.skew.seconds">sasl.oauthbearer.clock.skew.seconds</a></h4>
<p>The (optional) value in seconds to allow for differences between the time of the OAuth/OIDC identity provider and the broker.</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>30</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.expected.audience"></a><a id="brokerconfigs_sasl.oauthbearer.expected.audience" href="#brokerconfigs_sasl.oauthbearer.expected.audience">sasl.oauthbearer.expected.audience</a></h4>
<p>The (optional) comma-delimited setting for the broker to use to verify that the JWT was issued for one of the expected audiences. The JWT will be inspected for the standard OAuth "aud" claim and if this value is set, the broker will match the value from JWT's "aud" claim  to see if there is an exact match. If there is no match, the broker will reject the JWT and authentication will fail.</p>
<table><tbody>
<tr><th>Type:</th><td>list</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.expected.issuer"></a><a id="brokerconfigs_sasl.oauthbearer.expected.issuer" href="#brokerconfigs_sasl.oauthbearer.expected.issuer">sasl.oauthbearer.expected.issuer</a></h4>
<p>The (optional) setting for the broker to use to verify that the JWT was created by the expected issuer. The JWT will be inspected for the standard OAuth "iss" claim and if this value is set, the broker will match it exactly against what is in the JWT's "iss" claim. If there is no match, the broker will reject the JWT and authentication will fail.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwks.endpoint.refresh.ms"></a><a id="brokerconfigs_sasl.oauthbearer.jwks.endpoint.refresh.ms" href="#brokerconfigs_sasl.oauthbearer.jwks.endpoint.refresh.ms">sasl.oauthbearer.jwks.endpoint.refresh.ms</a></h4>
<p>The (optional) value in milliseconds for the broker to wait between refreshing its JWKS (JSON Web Key Set) cache that contains the keys to verify the signature of the JWT.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>3600000 (1 hour)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms"></a><a id="brokerconfigs_sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms" href="#brokerconfigs_sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms">sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms</a></h4>
<p>The (optional) value in milliseconds for the maximum wait between attempts to retrieve the JWKS (JSON Web Key Set) from the external authentication provider. JWKS retrieval uses an exponential backoff algorithm with an initial wait based on the sasl.oauthbearer.jwks.endpoint.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms setting.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>10000 (10 seconds)</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.jwks.endpoint.retry.backoff.ms"></a><a id="brokerconfigs_sasl.oauthbearer.jwks.endpoint.retry.backoff.ms" href="#brokerconfigs_sasl.oauthbearer.jwks.endpoint.retry.backoff.ms">sasl.oauthbearer.jwks.endpoint.retry.backoff.ms</a></h4>
<p>The (optional) value in milliseconds for the initial wait between JWKS (JSON Web Key Set) retrieval attempts from the external authentication provider. JWKS retrieval uses an exponential backoff algorithm with an initial wait based on the sasl.oauthbearer.jwks.endpoint.retry.backoff.ms setting and will double in wait length between attempts up to a maximum wait length specified by the sasl.oauthbearer.jwks.endpoint.retry.backoff.max.ms setting.</p>
<table><tbody>
<tr><th>Type:</th><td>long</td></tr>
<tr><th>Default:</th><td>100</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.scope.claim.name"></a><a id="brokerconfigs_sasl.oauthbearer.scope.claim.name" href="#brokerconfigs_sasl.oauthbearer.scope.claim.name">sasl.oauthbearer.scope.claim.name</a></h4>
<p>The OAuth claim for the scope is often named "scope", but this (optional) setting can provide a different name to use for the scope included in the JWT payload's claims if the OAuth/OIDC provider uses a different name for that claim.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>scope</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="sasl.oauthbearer.sub.claim.name"></a><a id="brokerconfigs_sasl.oauthbearer.sub.claim.name" href="#brokerconfigs_sasl.oauthbearer.sub.claim.name">sasl.oauthbearer.sub.claim.name</a></h4>
<p>The OAuth claim for the subject is often named "sub", but this (optional) setting can provide a different name to use for the subject included in the JWT payload's claims if the OAuth/OIDC provider uses a different name for that claim.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>sub</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="security.providers"></a><a id="brokerconfigs_security.providers" href="#brokerconfigs_security.providers">security.providers</a></h4>
<p>A list of configurable creator classes each returning a provider implementing security algorithms. These classes should implement the <code>org.apache.kafka.common.security.auth.SecurityProviderCreator</code> interface.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.allow.dn.changes"></a><a id="brokerconfigs_ssl.allow.dn.changes" href="#brokerconfigs_ssl.allow.dn.changes">ssl.allow.dn.changes</a></h4>
<p>Indicates whether changes to the certificate distinguished name should be allowed during a dynamic reconfiguration of certificates or not.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.allow.san.changes"></a><a id="brokerconfigs_ssl.allow.san.changes" href="#brokerconfigs_ssl.allow.san.changes">ssl.allow.san.changes</a></h4>
<p>Indicates whether changes to the certificate subject alternative names should be allowed during a dynamic reconfiguration of certificates or not.</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.endpoint.identification.algorithm"></a><a id="brokerconfigs_ssl.endpoint.identification.algorithm" href="#brokerconfigs_ssl.endpoint.identification.algorithm">ssl.endpoint.identification.algorithm</a></h4>
<p>The endpoint identification algorithm to validate server hostname using server certificate. </p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>https</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.engine.factory.class"></a><a id="brokerconfigs_ssl.engine.factory.class" href="#brokerconfigs_ssl.engine.factory.class">ssl.engine.factory.class</a></h4>
<p>The class of type org.apache.kafka.common.security.auth.SslEngineFactory to provide SSLEngine objects. Default value is org.apache.kafka.common.security.ssl.DefaultSslEngineFactory. Alternatively, setting this to org.apache.kafka.common.security.ssl.CommonNameLoggingSslEngineFactory will log the common name of expired SSL certificates used by clients to authenticate at any of the brokers with log level INFO. Note that this will cause a tiny delay during establishment of new connections from mTLS clients to brokers due to the extra code for examining the certificate chain provided by the client. Note further that the implementation uses a custom truststore based on the standard Java truststore and thus might be considered a security risk due to not being as mature as the standard one.</p>
<table><tbody>
<tr><th>Type:</th><td>class</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.principal.mapping.rules"></a><a id="brokerconfigs_ssl.principal.mapping.rules" href="#brokerconfigs_ssl.principal.mapping.rules">ssl.principal.mapping.rules</a></h4>
<p>A list of rules for mapping from distinguished name from the client certificate to short name. The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, distinguished name of the X.500 certificate will be the principal. For more details on the format please see <a href="#security_authz"> security authorization and acls</a>. Note that this configuration is ignored if an extension of KafkaPrincipalBuilder is provided by the <code>principal.builder.class</code> configuration.</p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>DEFAULT</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="ssl.secure.random.implementation"></a><a id="brokerconfigs_ssl.secure.random.implementation" href="#brokerconfigs_ssl.secure.random.implementation">ssl.secure.random.implementation</a></h4>
<p>The SecureRandom PRNG implementation to use for SSL cryptography operations. </p>
<table><tbody>
<tr><th>Type:</th><td>string</td></tr>
<tr><th>Default:</th><td>null</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>per-broker</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="telemetry.max.bytes"></a><a id="brokerconfigs_telemetry.max.bytes" href="#brokerconfigs_telemetry.max.bytes">telemetry.max.bytes</a></h4>
<p>The maximum size (after compression if compression is used) of telemetry metrics pushed from a client to the broker. The default value is 1048576 (1 MB).</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>1048576 (1 mebibyte)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.abort.timed.out.transaction.cleanup.interval.ms"></a><a id="brokerconfigs_transaction.abort.timed.out.transaction.cleanup.interval.ms" href="#brokerconfigs_transaction.abort.timed.out.transaction.cleanup.interval.ms">transaction.abort.timed.out.transaction.cleanup.interval.ms</a></h4>
<p>The interval at which to rollback transactions that have timed out</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>10000 (10 seconds)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.partition.verification.enable"></a><a id="brokerconfigs_transaction.partition.verification.enable" href="#brokerconfigs_transaction.partition.verification.enable">transaction.partition.verification.enable</a></h4>
<p>Enable verification that checks that the partition has been added to the transaction before writing transactional records to the partition</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>true</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>cluster-wide</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.remove.expired.transaction.cleanup.interval.ms"></a><a id="brokerconfigs_transaction.remove.expired.transaction.cleanup.interval.ms" href="#brokerconfigs_transaction.remove.expired.transaction.cleanup.interval.ms">transaction.remove.expired.transaction.cleanup.interval.ms</a></h4>
<p>The interval at which to remove transactions that have expired due to <code>transactional.id.expiration.ms</code> passing</p>
<table><tbody>
<tr><th>Type:</th><td>int</td></tr>
<tr><th>Default:</th><td>3600000 (1 hour)</td></tr>
<tr><th>Valid Values:</th><td>[1,...]</td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
<li>
<h4><a id="transaction.two.phase.commit.enable"></a><a id="brokerconfigs_transaction.two.phase.commit.enable" href="#brokerconfigs_transaction.two.phase.commit.enable">transaction.two.phase.commit.enable</a></h4>
<p>Allow participation in Two-Phase Commit (2PC) transactions with an external transaction coordinator</p>
<table><tbody>
<tr><th>Type:</th><td>boolean</td></tr>
<tr><th>Default:</th><td>false</td></tr>
<tr><th>Valid Values:</th><td></td></tr>
<tr><th>Importance:</th><td>low</td></tr>
<tr><th>Update Mode:</th><td>read-only</td></tr>
</tbody></table>
</li>
</ul>

